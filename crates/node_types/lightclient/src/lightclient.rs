use anyhow::{Context, Result};
use prism_common::digest::Digest;
use prism_da::LightDataAvailabilityLayer;
use prism_errors::GeneralError;
use prism_keys::VerifyingKey;
use std::{self, future::Future, sync::Arc};
use tokio::sync::{broadcast, RwLock};

#[allow(unused_imports)]
use sp1_verifier::Groth16Verifier;

use crate::events::{
    forward_lumina_events, forward_lumina_events_and_update_height, EventPublisher,
    LightClientEvent,
};

fn spawn_task<F>(future: F)
where
    F: Future<Output = ()> + Send + 'static,
{
    #[cfg(target_arch = "wasm32")]
    {
        wasm_bindgen_futures::spawn_local(future);
    }
    #[cfg(not(target_arch = "wasm32"))]
    {
        tokio::spawn(future);
    }
}

pub struct LightClient {
    #[cfg(not(target_arch = "wasm32"))]
    pub da: Arc<dyn LightDataAvailabilityLayer + Send + Sync>,
    #[cfg(target_arch = "wasm32")]
    pub da: Arc<dyn LightDataAvailabilityLayer>,
    /// The public key of the prover, used for verifying the signature of the epochs.
    pub prover_pubkey: Option<VerifyingKey>,
    /// The verification key for the SP1 program, generated by `vk.bytes32()`.
    pub sp1_vkey: String,
    /// The height to start syncing from.
    pub start_height: u64,
    /// The event publisher.
    pub event_publisher: EventPublisher,
    // The latest commitment.
    latest_commitment: Arc<RwLock<Option<Digest>>>,
}

#[allow(dead_code)]
impl LightClient {
    pub fn new(
        #[cfg(not(target_arch = "wasm32"))] da: Arc<dyn LightDataAvailabilityLayer + Send + Sync>,
        #[cfg(target_arch = "wasm32")] da: Arc<dyn LightDataAvailabilityLayer>,
        start_height: u64,
        prover_pubkey: Option<VerifyingKey>,
        sp1_vkey: String,
        event_publisher: EventPublisher,
    ) -> LightClient {
        LightClient {
            da,
            sp1_vkey,
            prover_pubkey,
            start_height,
            event_publisher,
            latest_commitment: Arc::new(RwLock::new(None)),
        }
    }

    pub async fn run(self: Arc<Self>) -> Result<()> {
        // start listening for new headers to update sync target
        if let Some(lumina_event_subscriber) = self.da.event_subscriber() {
            let event_publisher = self.event_publisher.clone();

            spawn_task(async move {
                forward_lumina_events_and_update_height(
                    lumina_event_subscriber,
                    event_publisher,
                    sync_target,
                    height_update_tx,
                )
                .await;
            });
        }

        self.event_publisher.send(LightClientEvent::SyncStarted {
            height: self.start_height,
        });

        self.sync_loop()
            .await
            .map_err(|e| GeneralError::InitializationError(e.to_string()))
            .context("Sync loop failed")
    }

    async fn process_heights(&self, mut current_position: u64) {
        let mut height_rx = self.da.subscribe_to_heights();
        self.event_publisher.send(LightClientEvent::EpochVerificationStarted {
            height: current_position,
        });

        loop {
            match height_rx.recv().await {
                Ok(target) => {
                    for i in current_position..target {
                        match self.da.get_finalized_epoch(i + 1).await {
                            Ok(Some(finalized_epoch)) => {
                                if let Some(pubkey) = &self.prover_pubkey {
                                    match finalized_epoch.verify_signature(pubkey.clone()) {
                                        Ok(_) => trace!(
                                            "valid signature for epoch {}",
                                            finalized_epoch.height
                                        ),
                                        Err(e) => {
                                            panic!("invalid signature in epoch {}: {:?}", i, e)
                                        }
                                    }
                                }

                                let public_values = match &finalized_epoch.proof {
                                    #[cfg(target_arch = "wasm32")]
                                    proof => proof.as_slice(),
                                    #[cfg(not(target_arch = "wasm32"))]
                                    proof => proof.public_values.as_slice(),
                                };

                                if public_values.len() < 64 {
                                    panic!(
                                        "public_values length is less than 64 bytes in epoch {}",
                                        finalized_epoch.height
                                    );
                                }

                                let mut slice = [0u8; 32];
                                slice.copy_from_slice(&public_values[..32]);
                                let proof_prev_commitment: Digest = Digest::from(slice);
                                let mut slice = [0u8; 32];
                                slice.copy_from_slice(&public_values[32..64]);
                                let proof_current_commitment: Digest = Digest::from(slice);
                                self.latest_commitment
                                    .write()
                                    .await
                                    .replace(proof_current_commitment);

                                if finalized_epoch.prev_commitment != proof_prev_commitment
                                    || finalized_epoch.current_commitment
                                        != proof_current_commitment
                                {
                                    error!(
                                        "Commitment mismatch:
                                        prev_commitment: {:?}, proof_prev_commitment: {:?},
                                        current_commitment: {:?}, proof_current_commitment: {:?}",
                                        finalized_epoch.prev_commitment,
                                        proof_prev_commitment,
                                        finalized_epoch.current_commitment,
                                        proof_current_commitment
                                    );
                                    panic!(
                                        "Commitment mismatch in epoch {}",
                                        finalized_epoch.height
                                    );
                                }

                                // SNARK verification
                                #[cfg(feature = "mock_prover")]
                                info!("mock_prover is activated, skipping proof verification");
                                self.event_publisher.send(LightClientEvent::EpochVerified {
                                    height: finalized_epoch.height,
                                });
                                #[cfg(not(feature = "mock_prover"))]
                                match Groth16Verifier::verify(
                                    &finalized_epoch.proof.as_slice(),
                                    public_values,
                                    &self.sp1_vkey,
                                    &sp1_verifier::GROTH16_VK_BYTES,
                                ) {
                                    Ok(_) => {
                                        self.event_publisher.send(
                                            LightClientEvent::EpochVerified {
                                                height: finalized_epoch.height,
                                            },
                                        );
                                        info!(
                                            "zkSNARK for epoch {} was validated successfully",
                                            finalized_epoch.height
                                        )
                                    }
                                    Err(err) => {
                                        self.event_publisher.send(
                                            LightClientEvent::EpochVerificationFailed {
                                                height: finalized_epoch.height,
                                                error: format!("{}", err),
                                            },
                                        );
                                        panic!(
                                            "failed to validate epoch at height {}: {:?}",
                                            finalized_epoch.height, err
                                        )
                                    }
                                }
                            }
                            Ok(None) => {
                                self.event_publisher
                                    .send(LightClientEvent::NoEpochFound { height: i + 1 });
                                debug!("no finalized epoch found at height: {}", i + 1);
                            }
                            Err(e) => {
                                self.event_publisher.send(
                                    LightClientEvent::EpochVerificationFailed {
                                        height: i + 1,
                                        error: format!("{}", e),
                                    },
                                );
                                debug!("light client: getting epoch: {}", e)
                            }
                        };
                    }
                    current_position = target;
                }
                Err(broadcast::error::RecvError::Closed) => {
                    self.event_publisher.send(LightClientEvent::HeightChannelClosed);
                    error!("Height channel closed unexpectedly");
                    break;
                }
                Err(broadcast::error::RecvError::Lagged(skipped)) => {
                    warn!("Lagged behind by {} messages", skipped);
                }
            }
        }
    }

    async fn sync_loop(self: Arc<Self>) -> Result<()> {
        info!("starting SNARK sync loop");
        let light_client = self.clone();
        let start_height = self.start_height;

        #[cfg(target_arch = "wasm32")]
        {
            wasm_bindgen_futures::spawn_local(async move {
                light_client.process_heights(start_height).await;
            });
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            tokio::spawn(async move {
                light_client.process_heights(start_height).await;
            })
            .await
            .map_err(|e| anyhow::anyhow!("Task failed: {:?}", e))?;
        }

        Ok(())
    }

    pub async fn get_latest_commitment(&self) -> Option<Digest> {
        *self.latest_commitment.read().await
    }
}
