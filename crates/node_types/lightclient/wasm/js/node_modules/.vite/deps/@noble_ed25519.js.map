{
  "version": 3,
  "sources": ["../../@noble/ed25519/index.js"],
  "sourcesContent": ["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nconst P = 2n ** 255n - 19n; // ed25519 is twisted edwards curve\nconst N = 2n ** 252n + 27742317777372353535851937790883648493n; // curve's (group) order\nconst Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an; // base point x\nconst Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n; // base point y\nconst CURVE = {\n    a: -1n, // where a=-1, d = -(121665/121666) == -(121665 * inv(121666)) mod P\n    d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,\n    p: P, n: N, h: 8, Gx, Gy // field prime, curve (group) order, cofactor\n};\nconst err = (m = '') => { throw new Error(m); }; // error helper, messes-up stack trace\nconst str = (s) => typeof s === 'string'; // is string\nconst isu8 = (a) => (a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\nconst au8 = (a, l) => // is Uint8Array (of specific length)\n !isu8(a) || (typeof l === 'number' && l > 0 && a.length !== l) ?\n    err('Uint8Array of valid length expected') : a;\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len) => au8(str(a) ? h2b(a) : u8n(au8(a)), len); // norm(hex/u8a) to u8a\nconst mod = (a, b = P) => { let r = a % b; return r >= 0n ? r : b + r; }; // mod division\nconst isPoint = (p) => (p instanceof Point ? p : err('Point expected')); // is xyzt point\nclass Point {\n    constructor(ex, ey, ez, et) {\n        this.ex = ex;\n        this.ey = ey;\n        this.ez = ez;\n        this.et = et;\n    }\n    static fromAffine(p) { return new Point(p.x, p.y, 1n, mod(p.x * p.y)); }\n    static fromHex(hex, zip215 = false) {\n        const { d } = CURVE;\n        hex = toU8(hex, 32);\n        const normed = hex.slice(); // copy the array to not mess it up\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80; // adjust first LE byte = last BE byte\n        const y = b2n_LE(normed); // decode as little-endian, convert to num\n        if (zip215 && !(0n <= y && y < 2n ** 256n))\n            err('bad y coord 1'); // zip215=true  [1..2^256-1]\n        if (!zip215 && !(0n <= y && y < P))\n            err('bad y coord 2'); // zip215=false [1..P-1]\n        const y2 = mod(y * y); // y²\n        const u = mod(y2 - 1n); // u=y²-1\n        const v = mod(d * y2 + 1n); // v=dy²+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid)\n            err('bad y coordinate 3'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd)\n            err('bad y coord 3'); // x=0 and x_0 = 1\n        if (isLastByteOdd !== isXOdd)\n            x = mod(-x);\n        return new Point(x, y, 1n, mod(x * y)); // Z=1, T=xy\n    }\n    get x() { return this.toAffine().x; } // .x, .y will call expensive toAffine.\n    get y() { return this.toAffine().y; } // Should be used with care.\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = isPoint(other); // isPoint() checks class equality\n        const X1Z2 = mod(X1 * Z2), X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2), Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() { return this.equals(I); }\n    negate() {\n        return new Point(mod(-this.ex), this.ey, this.ez, mod(-this.et));\n    }\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this; // Cost: 4M + 4S + 1*a + 6add + 1*2\n        const { a } = CURVE; // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this; // Cost: 8M + 1*k + 8add + 1*2.\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = isPoint(other); // doesn't check if other on-curve\n        const { a, d } = CURVE; // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = mod(X1 * X2);\n        const B = mod(Y1 * Y2);\n        const C = mod(T1 * d * T2);\n        const D = mod(Z1 * Z2);\n        const E = mod((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = mod(D - C);\n        const G = mod(D + C);\n        const H = mod(B - a * A);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    mul(n, safe = true) {\n        if (n === 0n)\n            return safe === true ? err('cannot multiply by 0') : I;\n        if (!(typeof n === 'bigint' && 0n < n && n < N))\n            err('invalid scalar, must be < L');\n        if (!safe && this.is0() || n === 1n)\n            return this; // safe=true bans 0. safe=false allows 0.\n        if (this.equals(G))\n            return wNAF(n).p; // use wNAF precomputes for base points\n        let p = I, f = G; // init result point & fake point\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) { // double-and-add ladder\n            if (n & 1n)\n                p = p.add(d); // if bit is present, add to point\n            else if (safe)\n                f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    multiply(scalar) { return this.mul(scalar); } // Aliases for compatibilty\n    clearCofactor() { return this.mul(BigInt(CURVE.h), false); } // multiply by cofactor\n    isSmallOrder() { return this.clearCofactor().is0(); } // check if P is small order\n    isTorsionFree() {\n        let p = this.mul(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n)\n            p = p.add(this); // P^(N+1)             // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this; // (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy)\n        if (this.equals(I))\n            return { x: 0n, y: 1n }; // fast-path for zero point\n        const iz = invert(z); // z^-1: invert z\n        if (mod(z * iz) !== 1n)\n            err('invalid inverse'); // (z * z^-1) must be 1, otherwise bad math\n        return { x: mod(x * iz), y: mod(y * iz) }; // x = x*z^-1; y = y*z^-1\n    }\n    toRawBytes() {\n        const { x, y } = this.toAffine(); // convert to affine 2d point\n        const b = n2b_32LE(y); // encode number to 32 bytes\n        b[31] |= x & 1n ? 0x80 : 0; // store sign in first LE byte\n        return b;\n    }\n    toHex() { return b2h(this.toRawBytes()); } // encode to hex string\n}\nPoint.BASE = new Point(Gx, Gy, 1n, mod(Gx * Gy)); // Generator / Base point\nPoint.ZERO = new Point(0n, 1n, 1n, 0n); // Identity / Zero point\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (num, pad) => num.toString(16).padStart(pad, '0');\nconst b2h = (b) => Array.from(b).map(e => padh(e, 2)).join(''); // bytes to hex\nconst h2b = (hex) => {\n    const l = hex.length; // error if not string,\n    if (!str(hex) || l % 2)\n        err('hex invalid 1'); // or has odd length like 3, 5.\n    const arr = u8n(l / 2); // create result array\n    for (let i = 0; i < arr.length; i++) {\n        const j = i * 2;\n        const h = hex.slice(j, j + 2); // hexByte. slice is faster than substr\n        const b = Number.parseInt(h, 16); // byte, created from string part\n        if (Number.isNaN(b) || b < 0)\n            err('hex invalid 2'); // byte must be valid 0 <= byte < 256\n        arr[i] = b;\n    }\n    return arr;\n};\nconst n2b_32LE = (num) => h2b(padh(num, 32 * 2)).reverse(); // number to bytes LE\nconst b2n_LE = (b) => BigInt('0x' + b2h(u8n(au8(b)).reverse())); // bytes LE to num\nconst concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\nconst invert = (num, md = P) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md); // no neg exponent for now\n    let a = mod(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) { // uses euclidean gcd algorithm\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? mod(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst pow2 = (x, power) => {\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\nconst uvRatio = (u, v) => {\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n)\n        x = mod(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\nconst modL_LE = (hash) => mod(b2n_LE(hash), N); // modulo L; but little-endian\nlet _shaS;\nconst sha512a = (...m) => etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m) => // Sync SHA512, not set by default\n typeof _shaS === 'function' ? _shaS(...m) : err('etc.sha512Sync not set');\nconst hash2extK = (hashed) => {\n    const head = hashed.slice(0, 32); // slice creates a copy, unlike subarray\n    head[0] &= 248; // Clamp bits: 0b1111_1000,\n    head[31] &= 127; // 0b0111_1111,\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(32, 64); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.mul(scalar); // public key point\n    const pointBytes = point.toRawBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, 32)).then(hash2extK);\nconst getExtendedPublicKey = (priv) => hash2extK(sha512s(toU8(priv, 32)));\nconst getPublicKeyAsync = (priv) => getExtendedPublicKeyAsync(priv).then(p => p.pointBytes);\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nfunction hashFinish(asynchronous, res) {\n    if (asynchronous)\n        return sha512a(res.hashable).then(res.finish);\n    return res.finish(sha512s(res.hashable));\n}\nconst _sign = (e, rBytes, msg) => {\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.mul(r).toRawBytes(); // R = [r]B\n    const hashable = concatB(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        const S = mod(r + modL_LE(hashed) * s, N); // S = (r + k * s) mod L; 0 <= s < l\n        return au8(concatB(R, n2b_32LE(S)), 64); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\nconst signAsync = async (msg, privKey) => {\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key async\n    const e = await getExtendedPublicKeyAsync(privKey); // pub,prfx\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(true, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst sign = (msg, privKey) => {\n    const m = toU8(msg); // RFC8032 5.1.6: sign msg with key sync\n    const e = getExtendedPublicKey(privKey); // pub,prfx\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinish(false, _sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst dvo = { zip215: true };\nconst _verify = (sig, msg, pub, opts = dvo) => {\n    msg = toU8(msg); // Message hex str/Bytes\n    sig = toU8(sig, 64); // Signature hex str/Bytes, must be 64 bytes\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A, R, s, SB, hashable = new Uint8Array();\n    try {\n        A = Point.fromHex(pub, zip215); // public key A decoded\n        R = Point.fromHex(sig.slice(0, 32), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = b2n_LE(sig.slice(32, 64)); // Decode second half as an integer S\n        SB = G.mul(s, false); // in the range 0 <= s < L\n        hashable = concatB(R.toRawBytes(), A.toRawBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    }\n    catch (error) { }\n    const finish = (hashed) => {\n        if (SB == null)\n            return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder())\n            return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.mul(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n// RFC8032 5.1.7: verification async, sync\nconst verifyAsync = async (s, m, p, opts = dvo) => hashFinish(true, _verify(s, m, p, opts));\nconst verify = (s, m, p, opts = dvo) => hashFinish(false, _verify(s, m, p, opts));\nconst cr = () => // We support: 1) browsers 2) node.js 19+\n typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\nconst etc = {\n    bytesToHex: b2h, hexToBytes: h2b, concatBytes: concatB,\n    mod, invert,\n    randomBytes: (len = 32) => {\n        const crypto = cr(); // Can be shimmed in node.js <= 18 to prevent error:\n        // import { webcrypto } from 'node:crypto';\n        // if (!globalThis.crypto) globalThis.crypto = webcrypto;\n        if (!crypto || !crypto.getRandomValues)\n            err('crypto.getRandomValues must be defined');\n        return crypto.getRandomValues(u8n(len));\n    },\n    sha512Async: async (...messages) => {\n        const crypto = cr();\n        if (!crypto || !crypto.subtle)\n            err('crypto.subtle or etc.sha512Async must be defined');\n        const m = concatB(...messages);\n        return u8n(await crypto.subtle.digest('SHA-512', m.buffer));\n    },\n    sha512Sync: undefined, // Actual logic below\n};\nObject.defineProperties(etc, { sha512Sync: {\n        configurable: false, get() { return _shaS; }, set(f) { if (!_shaS)\n            _shaS = f; },\n    } });\nconst utils = {\n    getExtendedPublicKeyAsync, getExtendedPublicKey,\n    randomPrivateKey: () => etc.randomBytes(32),\n    precompute(w = 8, p = G) { p.multiply(3n); w; return p; }, // no-op\n};\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = () => {\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for (let w = 0; w < windows; w++) { // Points are stored in array and used\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nlet Gpows = undefined; // precomputes for base point G\nconst wNAF = (n) => {\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p) => { let n = p.negate(); return cnd ? n : p; }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for (let w = 0; w < windows; w++) {\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        }\n        else { //          ^ can't add off2, off2 = I\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\nexport { getPublicKey, getPublicKeyAsync, sign, verify, // Remove the export to easily use in REPL\nsignAsync, verifyAsync, CURVE, etc, utils, Point as ExtendedPoint }; // envs like browser console\n"],
  "mappings": "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",
  "names": ["G", "P", "p", "n"]
}
