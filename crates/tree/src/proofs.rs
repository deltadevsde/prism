use anyhow::{Context, Result};
use jmt::{
    proof::{SparseMerkleProof, UpdateMerkleProof},
    KeyHash, RootHash,
};
use prism_common::{
    digest::Digest,
    hashchain::{Hashchain, HashchainEntry},
};
use prism_serde::binary::ToBinary;
use serde::{Deserialize, Serialize};

use crate::hasher::TreeHasher;

#[derive(Serialize, Deserialize)]
/// Represents a contiguous stream of [`Proof`]s leading from [`Batch::prev_root`] to [`Batch::new_root`].
/// Used as the input to the circuit.
pub struct Batch {
    pub prev_root: Digest,
    pub new_root: Digest,

    pub proofs: Vec<Proof>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Proof {
    Update(Box<UpdateProof>),
    Insert(Box<InsertProof>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
/// Represents an insertion proof for a newly created hashchain.
/// Currently, this proof is generated by
/// [`crate::operation::Operation::CreateAccount`] and
/// [`crate::operation::Operation::RegisterService`] operations.
// TODO(CRITICAL): Verify service's challenge input via a merkle proof of
// the service, and then signature verification with the contained VK.
pub struct InsertProof {
    /// Proof that the key does not already exist in the tree (i.e. it's not overwriting an existing key)
    pub non_membership_proof: NonMembershipProof,

    /// Post-insertion root hash of the tree
    pub new_root: Digest,
    /// Proof that the new hashchain is correctly inserted into the tree
    pub membership_proof: SparseMerkleProof<TreeHasher>,

    /// The new hashchain entry that was inserted.
    pub new_entry: HashchainEntry,
}

impl InsertProof {
    /// The method called in circuit to verify the state transition to the new root.
    pub fn verify(&self) -> Result<()> {
        self.non_membership_proof.verify().context("Invalid NonMembershipProof")?;

        let hashchain = Hashchain::from_entry(self.new_entry.clone())?;
        let serialized_hashchain = hashchain.encode_to_bytes()?;

        self.membership_proof.clone().verify_existence(
            RootHash(self.new_root.0),
            self.non_membership_proof.key,
            serialized_hashchain,
        )?;

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
/// Represents an update proof for an existing [`Hashchain`], updating it with a new [`HashchainEntry`].
pub struct UpdateProof {
    pub old_root: Digest,
    pub new_root: Digest,

    pub key: KeyHash,
    pub old_hashchain: Hashchain,
    pub new_entry: HashchainEntry,

    /// Inclusion proof of [`UpdateProof::old_hashchain`]
    pub inclusion_proof: SparseMerkleProof<TreeHasher>,
    /// Update proof for [`UpdateProof::key`] to be updated with [`UpdateProof::new_entry`]
    pub update_proof: UpdateMerkleProof<TreeHasher>,
}

impl UpdateProof {
    /// The method called in circuit to verify the state transition to the new root.
    pub fn verify(&self) -> Result<()> {
        // Verify existence of old value.
        // Otherwise, any arbitrary hashchain could be set as old_hashchain.
        let old_serialized_hashchain = self.old_hashchain.encode_to_bytes()?;
        self.inclusion_proof.verify_existence(
            RootHash(self.old_root.0),
            self.key,
            old_serialized_hashchain,
        )?;

        let mut hashchain_after_update = self.old_hashchain.clone();
        // Append the new entry and verify it's validity
        hashchain_after_update.add_entry(self.new_entry.clone())?;

        // Ensure the update proof corresponds to the new hashchain value
        let new_serialized_hashchain = hashchain_after_update.encode_to_bytes()?;
        self.update_proof.clone().verify_update(
            RootHash(self.old_root.0),
            RootHash(self.new_root.0),
            vec![(self.key, Some(new_serialized_hashchain))],
        )?;

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MembershipProof {
    pub root: Digest,
    pub proof: SparseMerkleProof<TreeHasher>,
    pub key: KeyHash,
    pub value: Hashchain,
}

impl MembershipProof {
    pub fn verify(&self) -> Result<()> {
        let value = self.value.encode_to_bytes()?;
        self.proof.verify_existence(RootHash(self.root.0), self.key, value)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NonMembershipProof {
    pub root: Digest,
    pub proof: SparseMerkleProof<TreeHasher>,
    pub key: KeyHash,
}

impl NonMembershipProof {
    pub fn verify(&self) -> Result<()> {
        self.proof.verify_nonexistence(RootHash(self.root.0), self.key)
    }
}
