{
  "@context": {
    "@version": 1.1,
    "@vocab": "https://schema.org/",
    "attributes": "rust:attributes",
    "crate": "https://w3id.org/rust/crate/",
    "crate_name": "name",
    "crate_path": "rust:cratePath",
    "cross_references": "rust:crossReferences",
    "dcterms": "http://purl.org/dc/terms/",
    "derives": "rust:derives",
    "edge_type": "rust:edgeType",
    "edges": "rust:edges",
    "failed_files": "rust:failedFiles",
    "fields": "rust:fields",
    "file_size": "contentSize",
    "files": "hasPart",
    "function_calls": "rust:functionCalls",
    "generics": "rust:generics",
    "items": "hasPart",
    "label": "rdfs:label",
    "last_modified": "dateModified",
    "local_variables": "rust:localVariables",
    "macro_invocations": "rust:macroInvocations",
    "name": "name",
    "nodes": "hasPart",
    "path": "rust:path",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "relative_path": "rust:relativePath",
    "rust": "https://w3id.org/rust/vocab#",
    "source": "rust:source",
    "stats": "rust:statistics",
    "successfully_parsed": "rust:successfullyParsed",
    "target": "rust:target",
    "target_type": "rust:targetType",
    "test_attributes": "rust:testAttributes",
    "total_files": "rust:totalFiles",
    "trait_name": "rust:traitName",
    "type_references": "rust:typeReferences",
    "variants": "rust:variants",
    "visibility": "rust:visibility",
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "@type": "rust:Crate",
  "@id": "crate:node_types_prover",
  "crate_name": "node_types_prover",
  "crate_path": "crates/node_types/prover",
  "files": [
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/tx_buffer.rs",
      "path": "../crates/node_types/prover/src/tx_buffer.rs",
      "relative_path": "crates/node_types/prover/src/tx_buffer.rs",
      "file_size": 771,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#use_prism_common_transaction_Transaction",
            "path": "prism_common :: transaction :: Transaction",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#use_std_collections_BTreeMap",
            "path": "std :: collections :: BTreeMap",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#TxBuffer",
            "name": "TxBuffer",
            "visibility": "pub",
            "fields": [
              {
                "name": "transactions",
                "type_name": "BTreeMap < u64 , Vec < Transaction > >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#impl_TxBuffer",
            "target_type": "TxBuffer",
            "trait_name": null,
            "items": [
              "pub fn new () -> Self { TxBuffer { transactions : BTreeMap :: new () , } }",
              "pub fn take_to_range (& mut self , end : u64) -> Vec < Transaction > { let keys : Vec < u64 > = self . transactions . range (..= end) . map (| (& k , _) | k) . collect () ; keys . into_iter () . filter_map (| k | self . transactions . remove (& k)) . flatten () . collect () }",
              "pub fn contains_pending (& self) -> bool { ! self . transactions . is_empty () }",
              "pub fn insert_at_height (& mut self , height : u64 , txs : Vec < Transaction >) { self . transactions . entry (height) . or_default () . extend (txs) ; }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#use_prism_common_transaction_Transaction",
            "path": "prism_common :: transaction :: Transaction",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#use_std_collections_BTreeMap",
            "path": "std :: collections :: BTreeMap",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#TxBuffer",
            "name": "TxBuffer",
            "visibility": "pub",
            "fields": [
              {
                "name": "transactions",
                "type_name": "BTreeMap < u64 , Vec < Transaction > >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/tx_buffer.rs#impl_TxBuffer",
            "target_type": "TxBuffer",
            "trait_name": null,
            "items": [
              "pub fn new () -> Self { TxBuffer { transactions : BTreeMap :: new () , } }",
              "pub fn take_to_range (& mut self , end : u64) -> Vec < Transaction > { let keys : Vec < u64 > = self . transactions . range (..= end) . map (| (& k , _) | k) . collect () ; keys . into_iter () . filter_map (| k | self . transactions . remove (& k)) . flatten () . collect () }",
              "pub fn contains_pending (& self) -> bool { ! self . transactions . is_empty () }",
              "pub fn insert_at_height (& mut self , height : u64 , txs : Vec < Transaction >) { self . transactions . entry (height) . or_default () . extend (txs) ; }"
            ],
            "generics": []
          },
          "type_references": [
            "TxBuffer"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/webserver.rs",
      "path": "../crates/node_types/prover/src/webserver.rs",
      "relative_path": "crates/node_types/prover/src/webserver.rs",
      "file_size": 5366,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_crate_Prover",
            "path": "crate :: Prover",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_anyhow_{Result,bail}",
            "path": "anyhow :: { Result , bail }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_axum_{Json,extract_State,http_StatusCode,response_IntoResponse}",
            "path": "axum :: { Json , extract :: State , http :: StatusCode , response :: IntoResponse }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_prism_common_{api_{PrismApi,types_{AccountRequest,AccountResponse,CommitmentResponse},},transaction_Transaction,}",
            "path": "prism_common :: { api :: { PrismApi , types :: { AccountRequest , AccountResponse , CommitmentResponse } , } , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_std_{net_SocketAddr,sync_Arc}",
            "path": "std :: { net :: SocketAddr , sync :: Arc }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_tokio_net_TcpListener",
            "path": "tokio :: net :: TcpListener",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_tower_http_cors_CorsLayer",
            "path": "tower_http :: cors :: CorsLayer",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_utoipa_{OpenApi,openapi_{Info,OpenApiBuilder},}",
            "path": "utoipa :: { OpenApi , openapi :: { Info , OpenApiBuilder } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_utoipa_axum_{router_OpenApiRouter,routes}",
            "path": "utoipa_axum :: { router :: OpenApiRouter , routes }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_utoipa_swagger_ui_SwaggerUi",
            "path": "utoipa_swagger_ui :: SwaggerUi",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/webserver.rs#WebServerConfig",
            "name": "WebServerConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "enabled",
                "type_name": "bool",
                "visibility": "pub"
              },
              {
                "name": "host",
                "type_name": "String",
                "visibility": "pub"
              },
              {
                "name": "port",
                "type_name": "u16",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/webserver.rs#impl_Default_WebServerConfig",
            "target_type": "WebServerConfig",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { WebServerConfig { enabled : true , host : \"127.0.0.1\" . to_string () , port : 41997 , } }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/webserver.rs#WebServer",
            "name": "WebServer",
            "visibility": "pub",
            "fields": [
              {
                "name": "cfg",
                "type_name": "WebServerConfig",
                "visibility": "pub"
              },
              {
                "name": "session",
                "type_name": "Arc < Prover >",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/webserver.rs#ApiDoc",
            "name": "ApiDoc",
            "visibility": "private",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/webserver.rs#impl_WebServer",
            "target_type": "WebServer",
            "trait_name": null,
            "items": [
              "pub fn new (cfg : WebServerConfig , session : Arc < Prover >) -> Self { Self { cfg , session } }",
              "pub async fn start (& self , cancellation_token : CancellationToken) -> Result < () > { if ! self . cfg . enabled { bail ! (\"Webserver is disabled\") } let (router , api) = OpenApiRouter :: with_openapi (ApiDoc :: openapi ()) . routes (routes ! (get_account)) . routes (routes ! (post_transaction)) . routes (routes ! (get_commitment)) . layer (CorsLayer :: permissive ()) . with_state (self . session . clone ()) . split_for_parts () ; let api = OpenApiBuilder :: from (api) . info (Info :: new (\"Prism Full Node API\" , \"0.1.0\")) . build () ; let router = router . merge (SwaggerUi :: new (\"/swagger-ui\") . url (\"/api-docs/openapi.json\" , api)) ; let addr = SocketAddr :: new (self . cfg . host . parse () . expect (\"IP address can be parsed\") , self . cfg . port ,) ; let listener = TcpListener :: bind (addr) . await . expect (\"Binding to address works\") ; let server = axum :: serve (listener , router . into_make_service ()) ; let socket_addr = server . local_addr () ? ; info ! (\"Starting webserver on {}:{}\" , self . cfg . host , socket_addr . port ()) ; let cancellation_token = cancellation_token . clone () ; server . with_graceful_shutdown (async move { cancellation_token . cancelled () . await ; info ! (\"Webserver shutting down gracefully\") ; }) . await ? ; Ok (()) }"
            ],
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/webserver.rs#post_transaction",
            "name": "post_transaction",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "State (session) : State < Arc < Prover > >",
              "Json (transaction) : Json < Transaction >"
            ],
            "output": "impl IntoResponse",
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/webserver.rs#get_account",
            "name": "get_account",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "State (session) : State < Arc < Prover > >",
              "Json (request) : Json < AccountRequest >"
            ],
            "output": "impl IntoResponse",
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/webserver.rs#get_commitment",
            "name": "get_commitment",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "State (session) : State < Arc < Prover > >"
            ],
            "output": "impl IntoResponse",
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_crate_Prover",
            "path": "crate :: Prover",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_anyhow_{Result,bail}",
            "path": "anyhow :: { Result , bail }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_axum_{Json,extract_State,http_StatusCode,response_IntoResponse}",
            "path": "axum :: { Json , extract :: State , http :: StatusCode , response :: IntoResponse }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_prism_common_{api_{PrismApi,types_{AccountRequest,AccountResponse,CommitmentResponse},},transaction_Transaction,}",
            "path": "prism_common :: { api :: { PrismApi , types :: { AccountRequest , AccountResponse , CommitmentResponse } , } , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_std_{net_SocketAddr,sync_Arc}",
            "path": "std :: { net :: SocketAddr , sync :: Arc }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_tokio_net_TcpListener",
            "path": "tokio :: net :: TcpListener",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_tower_http_cors_CorsLayer",
            "path": "tower_http :: cors :: CorsLayer",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_utoipa_{OpenApi,openapi_{Info,OpenApiBuilder},}",
            "path": "utoipa :: { OpenApi , openapi :: { Info , OpenApiBuilder } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_utoipa_axum_{router_OpenApiRouter,routes}",
            "path": "utoipa_axum :: { router :: OpenApiRouter , routes }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/webserver.rs#use_utoipa_swagger_ui_SwaggerUi",
            "path": "utoipa_swagger_ui :: SwaggerUi",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/webserver.rs#WebServerConfig",
            "name": "WebServerConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "enabled",
                "type_name": "bool",
                "visibility": "pub"
              },
              {
                "name": "host",
                "type_name": "String",
                "visibility": "pub"
              },
              {
                "name": "port",
                "type_name": "u16",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Debug",
            "Serialize",
            "Deserialize",
            "Clone"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/webserver.rs#impl_Default_WebServerConfig",
            "target_type": "WebServerConfig",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { WebServerConfig { enabled : true , host : \"127.0.0.1\" . to_string () , port : 41997 , } }"
            ],
            "generics": []
          },
          "type_references": [
            "WebServerConfig"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/webserver.rs#WebServer",
            "name": "WebServer",
            "visibility": "pub",
            "fields": [
              {
                "name": "cfg",
                "type_name": "WebServerConfig",
                "visibility": "pub"
              },
              {
                "name": "session",
                "type_name": "Arc < Prover >",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/webserver.rs#ApiDoc",
            "name": "ApiDoc",
            "visibility": "private",
            "fields": [],
            "generics": []
          },
          "derives": [
            "OpenApi"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/webserver.rs#impl_WebServer",
            "target_type": "WebServer",
            "trait_name": null,
            "items": [
              "pub fn new (cfg : WebServerConfig , session : Arc < Prover >) -> Self { Self { cfg , session } }",
              "pub async fn start (& self , cancellation_token : CancellationToken) -> Result < () > { if ! self . cfg . enabled { bail ! (\"Webserver is disabled\") } let (router , api) = OpenApiRouter :: with_openapi (ApiDoc :: openapi ()) . routes (routes ! (get_account)) . routes (routes ! (post_transaction)) . routes (routes ! (get_commitment)) . layer (CorsLayer :: permissive ()) . with_state (self . session . clone ()) . split_for_parts () ; let api = OpenApiBuilder :: from (api) . info (Info :: new (\"Prism Full Node API\" , \"0.1.0\")) . build () ; let router = router . merge (SwaggerUi :: new (\"/swagger-ui\") . url (\"/api-docs/openapi.json\" , api)) ; let addr = SocketAddr :: new (self . cfg . host . parse () . expect (\"IP address can be parsed\") , self . cfg . port ,) ; let listener = TcpListener :: bind (addr) . await . expect (\"Binding to address works\") ; let server = axum :: serve (listener , router . into_make_service ()) ; let socket_addr = server . local_addr () ? ; info ! (\"Starting webserver on {}:{}\" , self . cfg . host , socket_addr . port ()) ; let cancellation_token = cancellation_token . clone () ; server . with_graceful_shutdown (async move { cancellation_token . cancelled () . await ; info ! (\"Webserver shutting down gracefully\") ; }) . await ? ; Ok (()) }"
            ],
            "generics": []
          },
          "type_references": [
            "WebServer"
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/webserver.rs#post_transaction",
            "name": "post_transaction",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "State (session) : State < Arc < Prover > >",
              "Json (transaction) : Json < Transaction >"
            ],
            "output": "impl IntoResponse",
            "generics": []
          },
          "function_calls": [
            {
              "callee": "validate_and_queue_update",
              "is_method": true,
              "receiver_type": "session"
            },
            {
              "callee": "into_response",
              "is_method": true
            },
            {
              "callee": "into_response",
              "is_method": true
            }
          ],
          "local_variables": [],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "format",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/webserver.rs#get_account",
            "name": "get_account",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "State (session) : State < Arc < Prover > >",
              "Json (request) : Json < AccountRequest >"
            ],
            "output": "impl IntoResponse",
            "generics": []
          },
          "function_calls": [
            {
              "callee": "get_account",
              "is_method": true,
              "receiver_type": "session"
            },
            {
              "callee": "into_response",
              "is_method": true
            },
            {
              "callee": "into_response",
              "is_method": true
            },
            {
              "callee": "Json",
              "is_method": false
            }
          ],
          "local_variables": [
            {
              "name": "get_account_result",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "format",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/webserver.rs#get_commitment",
            "name": "get_commitment",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "State (session) : State < Arc < Prover > >"
            ],
            "output": "impl IntoResponse",
            "generics": []
          },
          "function_calls": [
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "session"
            },
            {
              "callee": "into_response",
              "is_method": true
            },
            {
              "callee": "Json",
              "is_method": false
            },
            {
              "callee": "into_response",
              "is_method": true
            },
            {
              "callee": "to_string",
              "is_method": true,
              "receiver_type": "e"
            }
          ],
          "local_variables": [],
          "type_references": [],
          "macro_invocations": []
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/lib.rs",
      "path": "../crates/node_types/prover/src/lib.rs",
      "relative_path": "crates/node_types/prover/src/lib.rs",
      "file_size": 266,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#prover",
            "name": "prover",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#prover_engine",
            "name": "prover_engine",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#sequencer",
            "name": "sequencer",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#syncer",
            "name": "syncer",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#tx_buffer",
            "name": "tx_buffer",
            "visibility": "private",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#webserver",
            "name": "webserver",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/lib.rs#use_prover_{Config,Prover,ProverEngineConfig,SequencerConfig,SyncerConfig}",
            "path": "prover :: { Config , Prover , ProverEngineConfig , SequencerConfig , SyncerConfig }",
            "visibility": "pub"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/lib.rs#use_webserver_WebServerConfig",
            "path": "webserver :: WebServerConfig",
            "visibility": "pub"
          }
        }
      ],
      "enhanced_items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#prover",
            "name": "prover",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#prover_engine",
            "name": "prover_engine",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#sequencer",
            "name": "sequencer",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#syncer",
            "name": "syncer",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#tx_buffer",
            "name": "tx_buffer",
            "visibility": "private",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/lib.rs#webserver",
            "name": "webserver",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/lib.rs#use_prover_{Config,Prover,ProverEngineConfig,SequencerConfig,SyncerConfig}",
            "path": "prover :: { Config , Prover , ProverEngineConfig , SequencerConfig , SyncerConfig }",
            "visibility": "pub"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/lib.rs#use_webserver_WebServerConfig",
            "path": "webserver :: WebServerConfig",
            "visibility": "pub"
          }
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/sequencer.rs",
      "path": "../crates/node_types/prover/src/sequencer.rs",
      "relative_path": "crates/node_types/prover/src/sequencer.rs",
      "file_size": 7881,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_anyhow_{Context,Result,bail}",
            "path": "anyhow :: { Context , Result , bail }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_jmt_KeyHash",
            "path": "jmt :: KeyHash",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_common_{account_Account,digest_Digest,operation_Operation,transaction_Transaction,}",
            "path": "prism_common :: { account :: Account , digest :: Digest , operation :: Operation , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_da_{DataAvailabilityLayer,FinalizedEpoch}",
            "path": "prism_da :: { DataAvailabilityLayer , FinalizedEpoch }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_keys_SigningKey",
            "path": "prism_keys :: SigningKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_tree_{AccountResponse_*,hasher_TreeHasher,key_directory_tree_KeyDirectoryTree,proofs_Proof,snarkable_tree_SnarkableTree,}",
            "path": "prism_tree :: { AccountResponse :: * , hasher :: TreeHasher , key_directory_tree :: KeyDirectoryTree , proofs :: Proof , snarkable_tree :: SnarkableTree , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_tokio_sync_RwLock",
            "path": "tokio :: sync :: RwLock",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_crate_prover_engine_ProverEngine",
            "path": "crate :: prover_engine :: ProverEngine",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/sequencer.rs#Sequencer",
            "name": "Sequencer",
            "visibility": "pub",
            "fields": [
              {
                "name": "db",
                "type_name": "Arc < Box < dyn Database > >",
                "visibility": "private"
              },
              {
                "name": "da",
                "type_name": "Arc < dyn DataAvailabilityLayer >",
                "visibility": "private"
              },
              {
                "name": "tree",
                "type_name": "Arc < RwLock < KeyDirectoryTree < Box < dyn Database > > > >",
                "visibility": "private"
              },
              {
                "name": "pending_transactions",
                "type_name": "Arc < RwLock < Vec < Transaction > > >",
                "visibility": "private"
              },
              {
                "name": "signing_key",
                "type_name": "SigningKey",
                "visibility": "private"
              },
              {
                "name": "latest_epoch_da_height",
                "type_name": "Arc < RwLock < u64 > >",
                "visibility": "private"
              },
              {
                "name": "batcher_enabled",
                "type_name": "bool",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/sequencer.rs#impl_Sequencer",
            "target_type": "Sequencer",
            "trait_name": null,
            "items": [
              "pub fn new (db : Arc < Box < dyn Database > > , da : Arc < dyn DataAvailabilityLayer > , config : & crate :: prover :: SequencerConfig , latest_epoch_da_height : Arc < RwLock < u64 > > ,) -> Result < Self > { let saved_epoch = match db . get_latest_epoch_height () { Ok (height) => height + 1 , Err (_) => { debug ! (\"no existing epoch state found, starting at epoch 0\") ; 0 } } ; let tree = Arc :: new (RwLock :: new (KeyDirectoryTree :: load (db . clone () , saved_epoch))) ; Ok (Sequencer { db , da , tree , pending_transactions : Arc :: new (RwLock :: new (Vec :: new ())) , signing_key : config . signing_key . clone () , latest_epoch_da_height , batcher_enabled : config . batcher_enabled , }) }",
              "pub async fn start (& self , cancellation_token : CancellationToken) -> Result < () > { if self . batcher_enabled { self . run_batch_poster (cancellation_token) . await } else { cancellation_token . cancelled () . await ; info ! (\"Sequencer: Gracefully stopped (batcher disabled)\") ; Ok (()) } }",
              "async fn run_batch_poster (& self , cancellation_token : CancellationToken) -> Result < () > { let mut height_rx = self . da . subscribe_to_heights () ; loop { tokio :: select ! { height_result = height_rx . recv () => { let height = height_result ?; trace ! (\"received height {}\" , height) ; let pending_transactions = { let mut ops = self . pending_transactions . write () . await ; std :: mem :: take (& mut * ops) } ; let tx_count = pending_transactions . len () ; if tx_count > 0 { match self . da . submit_transactions (pending_transactions) . await { Ok (submitted_height) => { info ! (\"post_batch_loop: submitted {} transactions at height {}\" , tx_count , submitted_height) ; } Err (e) => { error ! (\"post_batch_loop: Failed to submit transactions: {}\" , e) ; } } } else { debug ! (\"post_batch_loop: No pending transactions to submit at height {}\" , height) ; } } , _ = cancellation_token . cancelled () => { info ! (\"Sequencer: Gracefully stopping batch poster\") ; return Ok (()) ; } } } }",
              "pub async fn finalize_new_epoch (& self , epoch_height : u64 , transactions : Vec < Transaction > , prover_engine : & Arc < ProverEngine > , tip_da_height : u64 ,) -> Result < u64 > { let mut tree = self . tree . write () . await ; let batch = tree . process_batch (transactions) ? ; batch . verify () ? ; let (proof , compressed_proof) = prover_engine . prove_epoch (epoch_height , & batch , & self . db) . await ? ; let public_values = proof . public_values . to_vec () ; let mut epoch_json = FinalizedEpoch { height : epoch_height , prev_commitment : batch . prev_root , current_commitment : batch . new_root , proof , compressed_proof , public_values , signature : None , tip_da_height , } ; epoch_json . insert_signature (& self . signing_key) ? ; debug ! (\"Submitting finalized epoch height {} to DA\" , epoch_height) ; let da_height = self . da . submit_finalized_epoch (epoch_json . clone ()) . await ? ; debug ! (\"Finalized epoch height {} submitted to DA at height {}\" , epoch_height , da_height) ; let mut latest_da_height = self . latest_epoch_da_height . write () . await ; * latest_da_height = da_height ; self . db . add_epoch (& epoch_json) ? ; info ! (\"finalized new epoch at height {}\" , epoch_height) ; Ok (da_height) }",
              "pub async fn execute_block (& self , transactions : Vec < Transaction >) -> Result < Vec < Proof > > { debug ! (\"executing block with {} transactions\" , transactions . len ()) ; let mut proofs = Vec :: new () ; for transaction in transactions { match self . process_transaction (transaction . clone ()) . await { Ok (proof) => proofs . push (proof) , Err (e) => { warn ! (\"Failed to process transaction: {:?}. Error: {}\" , transaction , e) ; } } } Ok (proofs) }",
              "pub async fn validate_and_queue_update (& self , transaction : Transaction) -> Result < () > { if ! self . batcher_enabled { bail ! (\"Batcher is disabled, cannot queue transactions\") ; } match transaction . operation { Operation :: RegisterService { .. } | Operation :: CreateAccount { .. } => { Account :: default () . process_transaction (& transaction) ? ; } Operation :: AddKey { .. } | Operation :: RevokeKey { .. } | Operation :: AddData { .. } | Operation :: SetData { .. } => { let account_response = self . get_account (& transaction . id) . await ? ; let Found (mut account , _) = account_response else { bail ! (\"Account not found for id: {}\" , transaction . id) } ; account . process_transaction (& transaction) ? ; } } ; let mut pending = self . pending_transactions . write () . await ; pending . push (transaction) ; Ok (()) }",
              "pub async fn get_commitment (& self) -> Result < Digest > { let tree = self . tree . read () . await ; tree . get_commitment () . context (\"Failed to get commitment\") }",
              "pub async fn get_account (& self , id : & str) -> Result < prism_tree :: AccountResponse > { let tree = self . tree . read () . await ; let key_hash = KeyHash :: with :: < TreeHasher > (id) ; tree . get (key_hash) }",
              "pub fn get_pending_transactions (& self) -> Arc < RwLock < Vec < Transaction > > > { self . pending_transactions . clone () }",
              "pub fn get_db (& self) -> Arc < Box < dyn Database > > { self . db . clone () }",
              "pub async fn process_transaction (& self , transaction : Transaction) -> Result < Proof > { let mut tree = self . tree . write () . await ; tree . process_transaction (transaction) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_anyhow_{Context,Result,bail}",
            "path": "anyhow :: { Context , Result , bail }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_jmt_KeyHash",
            "path": "jmt :: KeyHash",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_common_{account_Account,digest_Digest,operation_Operation,transaction_Transaction,}",
            "path": "prism_common :: { account :: Account , digest :: Digest , operation :: Operation , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_da_{DataAvailabilityLayer,FinalizedEpoch}",
            "path": "prism_da :: { DataAvailabilityLayer , FinalizedEpoch }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_keys_SigningKey",
            "path": "prism_keys :: SigningKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_prism_tree_{AccountResponse_*,hasher_TreeHasher,key_directory_tree_KeyDirectoryTree,proofs_Proof,snarkable_tree_SnarkableTree,}",
            "path": "prism_tree :: { AccountResponse :: * , hasher :: TreeHasher , key_directory_tree :: KeyDirectoryTree , proofs :: Proof , snarkable_tree :: SnarkableTree , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_tokio_sync_RwLock",
            "path": "tokio :: sync :: RwLock",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/sequencer.rs#use_crate_prover_engine_ProverEngine",
            "path": "crate :: prover_engine :: ProverEngine",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/sequencer.rs#Sequencer",
            "name": "Sequencer",
            "visibility": "pub",
            "fields": [
              {
                "name": "db",
                "type_name": "Arc < Box < dyn Database > >",
                "visibility": "private"
              },
              {
                "name": "da",
                "type_name": "Arc < dyn DataAvailabilityLayer >",
                "visibility": "private"
              },
              {
                "name": "tree",
                "type_name": "Arc < RwLock < KeyDirectoryTree < Box < dyn Database > > > >",
                "visibility": "private"
              },
              {
                "name": "pending_transactions",
                "type_name": "Arc < RwLock < Vec < Transaction > > >",
                "visibility": "private"
              },
              {
                "name": "signing_key",
                "type_name": "SigningKey",
                "visibility": "private"
              },
              {
                "name": "latest_epoch_da_height",
                "type_name": "Arc < RwLock < u64 > >",
                "visibility": "private"
              },
              {
                "name": "batcher_enabled",
                "type_name": "bool",
                "visibility": "private"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/sequencer.rs#impl_Sequencer",
            "target_type": "Sequencer",
            "trait_name": null,
            "items": [
              "pub fn new (db : Arc < Box < dyn Database > > , da : Arc < dyn DataAvailabilityLayer > , config : & crate :: prover :: SequencerConfig , latest_epoch_da_height : Arc < RwLock < u64 > > ,) -> Result < Self > { let saved_epoch = match db . get_latest_epoch_height () { Ok (height) => height + 1 , Err (_) => { debug ! (\"no existing epoch state found, starting at epoch 0\") ; 0 } } ; let tree = Arc :: new (RwLock :: new (KeyDirectoryTree :: load (db . clone () , saved_epoch))) ; Ok (Sequencer { db , da , tree , pending_transactions : Arc :: new (RwLock :: new (Vec :: new ())) , signing_key : config . signing_key . clone () , latest_epoch_da_height , batcher_enabled : config . batcher_enabled , }) }",
              "pub async fn start (& self , cancellation_token : CancellationToken) -> Result < () > { if self . batcher_enabled { self . run_batch_poster (cancellation_token) . await } else { cancellation_token . cancelled () . await ; info ! (\"Sequencer: Gracefully stopped (batcher disabled)\") ; Ok (()) } }",
              "async fn run_batch_poster (& self , cancellation_token : CancellationToken) -> Result < () > { let mut height_rx = self . da . subscribe_to_heights () ; loop { tokio :: select ! { height_result = height_rx . recv () => { let height = height_result ?; trace ! (\"received height {}\" , height) ; let pending_transactions = { let mut ops = self . pending_transactions . write () . await ; std :: mem :: take (& mut * ops) } ; let tx_count = pending_transactions . len () ; if tx_count > 0 { match self . da . submit_transactions (pending_transactions) . await { Ok (submitted_height) => { info ! (\"post_batch_loop: submitted {} transactions at height {}\" , tx_count , submitted_height) ; } Err (e) => { error ! (\"post_batch_loop: Failed to submit transactions: {}\" , e) ; } } } else { debug ! (\"post_batch_loop: No pending transactions to submit at height {}\" , height) ; } } , _ = cancellation_token . cancelled () => { info ! (\"Sequencer: Gracefully stopping batch poster\") ; return Ok (()) ; } } } }",
              "pub async fn finalize_new_epoch (& self , epoch_height : u64 , transactions : Vec < Transaction > , prover_engine : & Arc < ProverEngine > , tip_da_height : u64 ,) -> Result < u64 > { let mut tree = self . tree . write () . await ; let batch = tree . process_batch (transactions) ? ; batch . verify () ? ; let (proof , compressed_proof) = prover_engine . prove_epoch (epoch_height , & batch , & self . db) . await ? ; let public_values = proof . public_values . to_vec () ; let mut epoch_json = FinalizedEpoch { height : epoch_height , prev_commitment : batch . prev_root , current_commitment : batch . new_root , proof , compressed_proof , public_values , signature : None , tip_da_height , } ; epoch_json . insert_signature (& self . signing_key) ? ; debug ! (\"Submitting finalized epoch height {} to DA\" , epoch_height) ; let da_height = self . da . submit_finalized_epoch (epoch_json . clone ()) . await ? ; debug ! (\"Finalized epoch height {} submitted to DA at height {}\" , epoch_height , da_height) ; let mut latest_da_height = self . latest_epoch_da_height . write () . await ; * latest_da_height = da_height ; self . db . add_epoch (& epoch_json) ? ; info ! (\"finalized new epoch at height {}\" , epoch_height) ; Ok (da_height) }",
              "pub async fn execute_block (& self , transactions : Vec < Transaction >) -> Result < Vec < Proof > > { debug ! (\"executing block with {} transactions\" , transactions . len ()) ; let mut proofs = Vec :: new () ; for transaction in transactions { match self . process_transaction (transaction . clone ()) . await { Ok (proof) => proofs . push (proof) , Err (e) => { warn ! (\"Failed to process transaction: {:?}. Error: {}\" , transaction , e) ; } } } Ok (proofs) }",
              "pub async fn validate_and_queue_update (& self , transaction : Transaction) -> Result < () > { if ! self . batcher_enabled { bail ! (\"Batcher is disabled, cannot queue transactions\") ; } match transaction . operation { Operation :: RegisterService { .. } | Operation :: CreateAccount { .. } => { Account :: default () . process_transaction (& transaction) ? ; } Operation :: AddKey { .. } | Operation :: RevokeKey { .. } | Operation :: AddData { .. } | Operation :: SetData { .. } => { let account_response = self . get_account (& transaction . id) . await ? ; let Found (mut account , _) = account_response else { bail ! (\"Account not found for id: {}\" , transaction . id) } ; account . process_transaction (& transaction) ? ; } } ; let mut pending = self . pending_transactions . write () . await ; pending . push (transaction) ; Ok (()) }",
              "pub async fn get_commitment (& self) -> Result < Digest > { let tree = self . tree . read () . await ; tree . get_commitment () . context (\"Failed to get commitment\") }",
              "pub async fn get_account (& self , id : & str) -> Result < prism_tree :: AccountResponse > { let tree = self . tree . read () . await ; let key_hash = KeyHash :: with :: < TreeHasher > (id) ; tree . get (key_hash) }",
              "pub fn get_pending_transactions (& self) -> Arc < RwLock < Vec < Transaction > > > { self . pending_transactions . clone () }",
              "pub fn get_db (& self) -> Arc < Box < dyn Database > > { self . db . clone () }",
              "pub async fn process_transaction (& self , transaction : Transaction) -> Result < Proof > { let mut tree = self . tree . write () . await ; tree . process_transaction (transaction) }"
            ],
            "generics": []
          },
          "type_references": [
            "Sequencer"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/syncer.rs",
      "path": "../crates/node_types/prover/src/syncer.rs",
      "relative_path": "crates/node_types/prover/src/syncer.rs",
      "file_size": 9588,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_anyhow_{Context,Result,anyhow}",
            "path": "anyhow :: { Context , Result , anyhow }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_common_transaction_Transaction",
            "path": "prism_common :: transaction :: Transaction",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_da_{DataAvailabilityLayer,FinalizedEpoch}",
            "path": "prism_da :: { DataAvailabilityLayer , FinalizedEpoch }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_keys_VerifyingKey",
            "path": "prism_keys :: VerifyingKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_telemetry_registry_metrics_registry_get_metrics",
            "path": "prism_telemetry_registry :: metrics_registry :: get_metrics",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_tokio_sync_{RwLock,broadcast}",
            "path": "tokio :: sync :: { RwLock , broadcast }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_crate_{prover_engine_ProverEngine,sequencer_Sequencer,tx_buffer_TxBuffer}",
            "path": "crate :: { prover_engine :: ProverEngine , sequencer :: Sequencer , tx_buffer :: TxBuffer }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/syncer.rs#Syncer",
            "name": "Syncer",
            "visibility": "pub",
            "fields": [
              {
                "name": "da",
                "type_name": "Arc < dyn DataAvailabilityLayer >",
                "visibility": "private"
              },
              {
                "name": "db",
                "type_name": "Arc < Box < dyn Database > >",
                "visibility": "private"
              },
              {
                "name": "tx_buffer",
                "type_name": "Arc < RwLock < TxBuffer > >",
                "visibility": "private"
              },
              {
                "name": "verifying_key",
                "type_name": "VerifyingKey",
                "visibility": "private"
              },
              {
                "name": "max_epochless_gap",
                "type_name": "u64",
                "visibility": "private"
              },
              {
                "name": "latest_epoch_da_height",
                "type_name": "Arc < RwLock < u64 > >",
                "visibility": "private"
              },
              {
                "name": "start_height",
                "type_name": "u64",
                "visibility": "private"
              },
              {
                "name": "sequencer",
                "type_name": "Arc < Sequencer >",
                "visibility": "private"
              },
              {
                "name": "prover_engine",
                "type_name": "Arc < ProverEngine >",
                "visibility": "private"
              },
              {
                "name": "is_prover_enabled",
                "type_name": "bool",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/syncer.rs#impl_Syncer",
            "target_type": "Syncer",
            "trait_name": null,
            "items": [
              "pub fn new (da : Arc < dyn DataAvailabilityLayer > , db : Arc < Box < dyn Database > > , config : & crate :: prover :: SyncerConfig , latest_epoch_da_height : Arc < RwLock < u64 > > , sequencer : Arc < Sequencer > , prover_engine : Arc < ProverEngine > ,) -> Self { Self { da , db , tx_buffer : Arc :: new (RwLock :: new (TxBuffer :: new ())) , verifying_key : config . verifying_key . clone () , max_epochless_gap : config . max_epochless_gap , latest_epoch_da_height , start_height : config . start_height , sequencer , prover_engine , is_prover_enabled : config . prover_enabled , } }",
              "pub fn get_da (& self) -> Arc < dyn DataAvailabilityLayer > { self . da . clone () }",
              "pub async fn start (& self , cancellation_token : CancellationToken) -> Result < () > { self . da . start () . await ? ; self . run_main_loop (cancellation_token) . await }",
              "async fn run_main_loop (& self , cancellation_token : CancellationToken) -> Result < () > { let mut height_rx = self . da . subscribe_to_heights () ; let historical_sync_height = height_rx . recv () . await ? ; let sync_start_height = match self . db . get_last_synced_height () { Ok (height) => height , Err (_) => { debug ! (\"no existing sync height found, setting sync height to start_height\") ; self . db . set_last_synced_height (& self . start_height) ? ; self . start_height } } ; self . sync_loop (sync_start_height , historical_sync_height , height_rx , cancellation_token ,) . await }",
              "async fn sync_loop (& self , start_height : u64 , end_height : u64 , mut incoming_heights : broadcast :: Receiver < u64 > , cancellation_token : CancellationToken ,) -> Result < () > { let mut current_height = start_height ; while current_height <= end_height { tokio :: select ! { result = self . process_da_height (current_height , false ,) => { result ?; self . db . set_last_synced_height (& current_height) ?; current_height += 1 ; } , _ = cancellation_token . cancelled () => { info ! (\"Syncer: Gracefully stopping during historical sync at height {}\" , current_height) ; return Ok (()) ; } } } info ! (\"finished historical sync from height {} to {}\" , start_height , end_height) ; loop { tokio :: select ! { height_result = incoming_heights . recv () => { let height = height_result ?; if height != current_height { return Err (anyhow ! (\"heights are not sequential: expected {}, got {}\" , current_height , height)) ; } self . process_da_height (height , true ,) . await ?; current_height += 1 ; self . db . set_last_synced_height (& current_height) ?; } , _ = cancellation_token . cancelled () => { info ! (\"Syncer: Gracefully stopping during real-time sync at height {}\" , current_height) ; return Ok (()) ; } } } }",
              "async fn process_da_height (& self , height : u64 , is_real_time : bool) -> Result < () > { let next_epoch_height = match self . db . get_latest_epoch_height () { Ok (height) => height + 1 , Err (_) => 0 , } ; let transactions = self . da . get_transactions (height) . await ? ; let epoch_result = self . da . get_finalized_epoch (height) . await ? ; trace ! (\"DA query at height {}: {} transactions, epoch present: {}\" , height , transactions . len () , ! epoch_result . is_empty ()) ; debug ! (\"processing {} height {}, next_epoch_height: {}\" , if is_real_time { \"new\" } else { \"old\" } , height , next_epoch_height) ; if ! epoch_result . is_empty () { for epoch in epoch_result { debug ! (\"Found finalized epoch {} at height {}\" , epoch . height , height) ; self . process_epoch (epoch) . await ? ; } } else { debug ! (\"No epoch found at height {}\" , height) ; } let mut tx_buffer = self . tx_buffer . write () . await ; if is_real_time && tx_buffer . contains_pending () && self . is_prover_enabled { let all_transactions : Vec < Transaction > = tx_buffer . take_to_range (height) ; debug ! (\"Starting epoch {} finalization with {} transactions at DA height {}\" , next_epoch_height , all_transactions . len () , height) ; self . sequencer . finalize_new_epoch (next_epoch_height , all_transactions , & self . prover_engine , height ,) . await ? ; } if ! transactions . is_empty () { tx_buffer . insert_at_height (height , transactions) ; return Ok (()) ; } let latest_epoch_height = * self . latest_epoch_da_height . read () . await ; if latest_epoch_height != 0 && height . saturating_sub (latest_epoch_height) >= self . max_epochless_gap { self . sequencer . finalize_new_epoch (next_epoch_height , Vec :: new () , & self . prover_engine , height) . await ? ; } if let Some (metrics) = get_metrics () { metrics . record_celestia_synced_height (height , vec ! []) ; metrics . record_current_epoch (next_epoch_height , vec ! []) ; } Ok (()) }",
              "async fn process_epoch (& self , epoch : FinalizedEpoch) -> Result < () > { let current_epoch = match self . db . get_latest_epoch_height () { Ok (height) => height + 1 , Err (_) => 0 , } ; if epoch . height < current_epoch { debug ! (\"epoch {} already processed internally\" , current_epoch) ; return Ok (()) ; } epoch . verify_signature (self . verifying_key . clone ()) . with_context (| | format ! (\"Invalid signature in epoch {}\" , epoch . height)) ? ; trace ! (\"valid signature for epoch {}\" , epoch . height) ; let prev_commitment = if epoch . height == 0 { self . sequencer . get_commitment () . await ? } else { self . db . get_epoch (& epoch . height . saturating_sub (1)) ? . current_commitment } ; if epoch . height != current_epoch { return Err (anyhow ! (\"epoch height mismatch: expected {}, got {}\" , current_epoch , epoch . height)) ; } if epoch . prev_commitment != prev_commitment { return Err (anyhow ! (\"previous commitment mismatch at epoch {}\" , current_epoch)) ; } let mut tx_buffer = self . tx_buffer . write () . await ; let transactions_to_execute = tx_buffer . take_to_range (epoch . tip_da_height) ; if ! transactions_to_execute . is_empty () { self . sequencer . execute_block (transactions_to_execute) . await ? ; } let new_commitment = self . sequencer . get_commitment () . await ? ; if epoch . current_commitment != new_commitment { return Err (anyhow ! (\"new commitment mismatch at epoch {}\" , current_epoch)) ; } match self . prover_engine . verify_epoch_proof (epoch . height , & epoch . proof) . await { Ok (_) => info ! (\"zkSNARK for epoch {} was validated successfully\" , epoch . height) , Err (err) => panic ! (\"failed to validate epoch at height {}: {:?}\" , epoch . height , err) , } debug ! (\"processed epoch {}. new commitment: {:?}\" , current_epoch , new_commitment) ; self . db . add_epoch (& epoch) ? ; Ok (()) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_anyhow_{Context,Result,anyhow}",
            "path": "anyhow :: { Context , Result , anyhow }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_common_transaction_Transaction",
            "path": "prism_common :: transaction :: Transaction",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_da_{DataAvailabilityLayer,FinalizedEpoch}",
            "path": "prism_da :: { DataAvailabilityLayer , FinalizedEpoch }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_keys_VerifyingKey",
            "path": "prism_keys :: VerifyingKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_prism_telemetry_registry_metrics_registry_get_metrics",
            "path": "prism_telemetry_registry :: metrics_registry :: get_metrics",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_tokio_sync_{RwLock,broadcast}",
            "path": "tokio :: sync :: { RwLock , broadcast }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/syncer.rs#use_crate_{prover_engine_ProverEngine,sequencer_Sequencer,tx_buffer_TxBuffer}",
            "path": "crate :: { prover_engine :: ProverEngine , sequencer :: Sequencer , tx_buffer :: TxBuffer }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/syncer.rs#Syncer",
            "name": "Syncer",
            "visibility": "pub",
            "fields": [
              {
                "name": "da",
                "type_name": "Arc < dyn DataAvailabilityLayer >",
                "visibility": "private"
              },
              {
                "name": "db",
                "type_name": "Arc < Box < dyn Database > >",
                "visibility": "private"
              },
              {
                "name": "tx_buffer",
                "type_name": "Arc < RwLock < TxBuffer > >",
                "visibility": "private"
              },
              {
                "name": "verifying_key",
                "type_name": "VerifyingKey",
                "visibility": "private"
              },
              {
                "name": "max_epochless_gap",
                "type_name": "u64",
                "visibility": "private"
              },
              {
                "name": "latest_epoch_da_height",
                "type_name": "Arc < RwLock < u64 > >",
                "visibility": "private"
              },
              {
                "name": "start_height",
                "type_name": "u64",
                "visibility": "private"
              },
              {
                "name": "sequencer",
                "type_name": "Arc < Sequencer >",
                "visibility": "private"
              },
              {
                "name": "prover_engine",
                "type_name": "Arc < ProverEngine >",
                "visibility": "private"
              },
              {
                "name": "is_prover_enabled",
                "type_name": "bool",
                "visibility": "private"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/syncer.rs#impl_Syncer",
            "target_type": "Syncer",
            "trait_name": null,
            "items": [
              "pub fn new (da : Arc < dyn DataAvailabilityLayer > , db : Arc < Box < dyn Database > > , config : & crate :: prover :: SyncerConfig , latest_epoch_da_height : Arc < RwLock < u64 > > , sequencer : Arc < Sequencer > , prover_engine : Arc < ProverEngine > ,) -> Self { Self { da , db , tx_buffer : Arc :: new (RwLock :: new (TxBuffer :: new ())) , verifying_key : config . verifying_key . clone () , max_epochless_gap : config . max_epochless_gap , latest_epoch_da_height , start_height : config . start_height , sequencer , prover_engine , is_prover_enabled : config . prover_enabled , } }",
              "pub fn get_da (& self) -> Arc < dyn DataAvailabilityLayer > { self . da . clone () }",
              "pub async fn start (& self , cancellation_token : CancellationToken) -> Result < () > { self . da . start () . await ? ; self . run_main_loop (cancellation_token) . await }",
              "async fn run_main_loop (& self , cancellation_token : CancellationToken) -> Result < () > { let mut height_rx = self . da . subscribe_to_heights () ; let historical_sync_height = height_rx . recv () . await ? ; let sync_start_height = match self . db . get_last_synced_height () { Ok (height) => height , Err (_) => { debug ! (\"no existing sync height found, setting sync height to start_height\") ; self . db . set_last_synced_height (& self . start_height) ? ; self . start_height } } ; self . sync_loop (sync_start_height , historical_sync_height , height_rx , cancellation_token ,) . await }",
              "async fn sync_loop (& self , start_height : u64 , end_height : u64 , mut incoming_heights : broadcast :: Receiver < u64 > , cancellation_token : CancellationToken ,) -> Result < () > { let mut current_height = start_height ; while current_height <= end_height { tokio :: select ! { result = self . process_da_height (current_height , false ,) => { result ?; self . db . set_last_synced_height (& current_height) ?; current_height += 1 ; } , _ = cancellation_token . cancelled () => { info ! (\"Syncer: Gracefully stopping during historical sync at height {}\" , current_height) ; return Ok (()) ; } } } info ! (\"finished historical sync from height {} to {}\" , start_height , end_height) ; loop { tokio :: select ! { height_result = incoming_heights . recv () => { let height = height_result ?; if height != current_height { return Err (anyhow ! (\"heights are not sequential: expected {}, got {}\" , current_height , height)) ; } self . process_da_height (height , true ,) . await ?; current_height += 1 ; self . db . set_last_synced_height (& current_height) ?; } , _ = cancellation_token . cancelled () => { info ! (\"Syncer: Gracefully stopping during real-time sync at height {}\" , current_height) ; return Ok (()) ; } } } }",
              "async fn process_da_height (& self , height : u64 , is_real_time : bool) -> Result < () > { let next_epoch_height = match self . db . get_latest_epoch_height () { Ok (height) => height + 1 , Err (_) => 0 , } ; let transactions = self . da . get_transactions (height) . await ? ; let epoch_result = self . da . get_finalized_epoch (height) . await ? ; trace ! (\"DA query at height {}: {} transactions, epoch present: {}\" , height , transactions . len () , ! epoch_result . is_empty ()) ; debug ! (\"processing {} height {}, next_epoch_height: {}\" , if is_real_time { \"new\" } else { \"old\" } , height , next_epoch_height) ; if ! epoch_result . is_empty () { for epoch in epoch_result { debug ! (\"Found finalized epoch {} at height {}\" , epoch . height , height) ; self . process_epoch (epoch) . await ? ; } } else { debug ! (\"No epoch found at height {}\" , height) ; } let mut tx_buffer = self . tx_buffer . write () . await ; if is_real_time && tx_buffer . contains_pending () && self . is_prover_enabled { let all_transactions : Vec < Transaction > = tx_buffer . take_to_range (height) ; debug ! (\"Starting epoch {} finalization with {} transactions at DA height {}\" , next_epoch_height , all_transactions . len () , height) ; self . sequencer . finalize_new_epoch (next_epoch_height , all_transactions , & self . prover_engine , height ,) . await ? ; } if ! transactions . is_empty () { tx_buffer . insert_at_height (height , transactions) ; return Ok (()) ; } let latest_epoch_height = * self . latest_epoch_da_height . read () . await ; if latest_epoch_height != 0 && height . saturating_sub (latest_epoch_height) >= self . max_epochless_gap { self . sequencer . finalize_new_epoch (next_epoch_height , Vec :: new () , & self . prover_engine , height) . await ? ; } if let Some (metrics) = get_metrics () { metrics . record_celestia_synced_height (height , vec ! []) ; metrics . record_current_epoch (next_epoch_height , vec ! []) ; } Ok (()) }",
              "async fn process_epoch (& self , epoch : FinalizedEpoch) -> Result < () > { let current_epoch = match self . db . get_latest_epoch_height () { Ok (height) => height + 1 , Err (_) => 0 , } ; if epoch . height < current_epoch { debug ! (\"epoch {} already processed internally\" , current_epoch) ; return Ok (()) ; } epoch . verify_signature (self . verifying_key . clone ()) . with_context (| | format ! (\"Invalid signature in epoch {}\" , epoch . height)) ? ; trace ! (\"valid signature for epoch {}\" , epoch . height) ; let prev_commitment = if epoch . height == 0 { self . sequencer . get_commitment () . await ? } else { self . db . get_epoch (& epoch . height . saturating_sub (1)) ? . current_commitment } ; if epoch . height != current_epoch { return Err (anyhow ! (\"epoch height mismatch: expected {}, got {}\" , current_epoch , epoch . height)) ; } if epoch . prev_commitment != prev_commitment { return Err (anyhow ! (\"previous commitment mismatch at epoch {}\" , current_epoch)) ; } let mut tx_buffer = self . tx_buffer . write () . await ; let transactions_to_execute = tx_buffer . take_to_range (epoch . tip_da_height) ; if ! transactions_to_execute . is_empty () { self . sequencer . execute_block (transactions_to_execute) . await ? ; } let new_commitment = self . sequencer . get_commitment () . await ? ; if epoch . current_commitment != new_commitment { return Err (anyhow ! (\"new commitment mismatch at epoch {}\" , current_epoch)) ; } match self . prover_engine . verify_epoch_proof (epoch . height , & epoch . proof) . await { Ok (_) => info ! (\"zkSNARK for epoch {} was validated successfully\" , epoch . height) , Err (err) => panic ! (\"failed to validate epoch at height {}: {:?}\" , epoch . height , err) , } debug ! (\"processed epoch {}. new commitment: {:?}\" , current_epoch , new_commitment) ; self . db . add_epoch (& epoch) ? ; Ok (()) }"
            ],
            "generics": []
          },
          "type_references": [
            "Syncer"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/prover/timer.rs",
      "path": "../crates/node_types/prover/src/prover/timer.rs",
      "relative_path": "crates/node_types/prover/src/prover/timer.rs",
      "file_size": 270,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/timer.rs#use_std_{future_Future,time_Duration}",
            "path": "std :: { future :: Future , time :: Duration }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/timer.rs#use_prism_common_api_PrismApiTimer",
            "path": "prism_common :: api :: PrismApiTimer",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/timer.rs#ProverTokioTimer",
            "name": "ProverTokioTimer",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/timer.rs#impl_PrismApiTimer_ProverTokioTimer",
            "target_type": "ProverTokioTimer",
            "trait_name": "PrismApiTimer",
            "items": [
              "fn sleep (duration : Duration) -> impl Future < Output = () > + Send { tokio :: time :: sleep (duration) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/timer.rs#use_std_{future_Future,time_Duration}",
            "path": "std :: { future :: Future , time :: Duration }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/timer.rs#use_prism_common_api_PrismApiTimer",
            "path": "prism_common :: api :: PrismApiTimer",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/timer.rs#ProverTokioTimer",
            "name": "ProverTokioTimer",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/timer.rs#impl_PrismApiTimer_ProverTokioTimer",
            "target_type": "ProverTokioTimer",
            "trait_name": "PrismApiTimer",
            "items": [
              "fn sleep (duration : Duration) -> impl Future < Output = () > + Send { tokio :: time :: sleep (duration) }"
            ],
            "generics": []
          },
          "type_references": [
            "ProverTokioTimer"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "path": "../crates/node_types/prover/src/prover/tests/mod.rs",
      "relative_path": "crates/node_types/prover/src/prover/tests/mod.rs",
      "file_size": 17302,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_super_*",
            "path": "super :: *",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_common_test_transaction_builder_TestTransactionBuilder",
            "path": "prism_common :: test_transaction_builder :: TestTransactionBuilder",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_keys_{CryptoAlgorithm,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_tree_proofs_Proof",
            "path": "prism_tree :: proofs :: Proof",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_std_{self,sync_Arc,time_Duration}",
            "path": "std :: { self , sync :: Arc , time :: Duration }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_tokio_spawn",
            "path": "tokio :: spawn",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_da_memory_InMemoryDataAvailabilityLayer",
            "path": "prism_da :: memory :: InMemoryDataAvailabilityLayer",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_storage_inmemory_InMemoryDatabase",
            "path": "prism_storage :: inmemory :: InMemoryDatabase",
            "visibility": "private"
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
            "name": "create_test_prover",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "algorithm : CryptoAlgorithm"
            ],
            "output": "Arc < Prover >",
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
            "name": "create_mock_transactions",
            "visibility": "private",
            "is_async": false,
            "is_unsafe": false,
            "inputs": [
              "service_id : String"
            ],
            "output": "Vec < Transaction >",
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
            "name": "test_posts_epoch_after_max_gap",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
            "name": "test_validate_and_queue_update",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "algorithm : CryptoAlgorithm"
            ],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
            "name": "test_process_transactions",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
            "name": "test_execute_block_with_invalid_tx",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
            "name": "test_execute_block",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
            "name": "test_finalize_new_epoch",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
            "name": "test_restart_sync_from_scratch",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
            "name": "test_prover_fullnode_commitment_sync_with_racing_transactions",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
            "name": "test_load_persisted_state",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_super_*",
            "path": "super :: *",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_common_test_transaction_builder_TestTransactionBuilder",
            "path": "prism_common :: test_transaction_builder :: TestTransactionBuilder",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_keys_{CryptoAlgorithm,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_tree_proofs_Proof",
            "path": "prism_tree :: proofs :: Proof",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_std_{self,sync_Arc,time_Duration}",
            "path": "std :: { self , sync :: Arc , time :: Duration }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_tokio_spawn",
            "path": "tokio :: spawn",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_da_memory_InMemoryDataAvailabilityLayer",
            "path": "prism_da :: memory :: InMemoryDataAvailabilityLayer",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#use_prism_storage_inmemory_InMemoryDatabase",
            "path": "prism_storage :: inmemory :: InMemoryDatabase",
            "visibility": "private"
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
            "name": "create_test_prover",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "algorithm : CryptoAlgorithm"
            ],
            "output": "Arc < Prover >",
            "generics": []
          },
          "function_calls": [
            {
              "callee": "InMemoryDataAvailabilityLayer::new",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Box::new",
              "is_method": false
            },
            {
              "callee": "InMemoryDatabase::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Config::default_with_key_algorithm",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "db"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            }
          ],
          "local_variables": [
            {
              "name": "da_layer",
              "is_mutable": false
            },
            {
              "name": "cfg",
              "is_mutable": true
            }
          ],
          "type_references": [
            "Arc",
            "Box"
          ],
          "macro_invocations": []
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
            "name": "create_mock_transactions",
            "visibility": "private",
            "is_async": false,
            "is_unsafe": false,
            "inputs": [
              "service_id : String"
            ],
            "output": "Vec < Transaction >",
            "generics": []
          },
          "function_calls": [
            {
              "callee": "TestTransactionBuilder::new",
              "is_method": false
            }
          ],
          "local_variables": [
            {
              "name": "transaction_builder",
              "is_mutable": true
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "vec",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
            "name": "test_posts_epoch_after_max_gap",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "create_test_prover",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "prover_handle"
            },
            {
              "callee": "subscribe_to_heights",
              "is_method": true
            },
            {
              "callee": "get_da",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "rx"
            },
            {
              "callee": "create_mock_transactions",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "finalize_new_epoch",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "rx"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_finalized_epoch",
              "is_method": true
            },
            {
              "callee": "get_da",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "first",
              "is_method": true,
              "receiver_type": "epochs"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "rx"
            },
            {
              "callee": "read",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "rx"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_finalized_epoch",
              "is_method": true
            },
            {
              "callee": "get_da",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "first",
              "is_method": true,
              "receiver_type": "epochs"
            }
          ],
          "local_variables": [
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "prover_handle",
              "is_mutable": false
            },
            {
              "name": "rx",
              "is_mutable": true
            },
            {
              "name": "height",
              "is_mutable": false
            },
            {
              "name": "test_transactions",
              "is_mutable": false
            },
            {
              "name": "commitment_before_epoch",
              "is_mutable": false
            },
            {
              "name": "initial_epoch_height",
              "is_mutable": false
            },
            {
              "name": "commitment_after_epoch",
              "is_mutable": false
            },
            {
              "name": "height",
              "is_mutable": false
            },
            {
              "name": "epochs",
              "is_mutable": false
            },
            {
              "name": "initial_epoch",
              "is_mutable": false
            },
            {
              "name": "height",
              "is_mutable": false
            },
            {
              "name": "current_epoch_height",
              "is_mutable": false
            },
            {
              "name": "height",
              "is_mutable": false
            },
            {
              "name": "epochs",
              "is_mutable": false
            },
            {
              "name": "gap_proof",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert_ne",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
            "name": "test_validate_and_queue_update",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [
              "algorithm : CryptoAlgorithm"
            ],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "create_test_prover",
              "is_method": false
            },
            {
              "callee": "TestTransactionBuilder::new",
              "is_method": false
            },
            {
              "callee": "commit",
              "is_method": true
            },
            {
              "callee": "register_service_with_random_keys",
              "is_method": true,
              "receiver_type": "transaction_builder"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "validate_and_queue_update",
              "is_method": true
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "transaction"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "validate_and_queue_update",
              "is_method": true
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "transaction"
            },
            {
              "callee": "get_pending_transactions",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "read",
              "is_method": true,
              "receiver_type": "pending_tx_arc"
            }
          ],
          "local_variables": [
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "transaction_builder",
              "is_mutable": true
            },
            {
              "name": "transaction",
              "is_mutable": false
            },
            {
              "name": "pending_tx_arc",
              "is_mutable": false
            },
            {
              "name": "pending_transactions",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
            "name": "test_process_transactions",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "create_test_prover",
              "is_method": false
            },
            {
              "callee": "TestTransactionBuilder::new",
              "is_method": false
            },
            {
              "callee": "commit",
              "is_method": true
            },
            {
              "callee": "register_service_with_random_keys",
              "is_method": true,
              "receiver_type": "transaction_builder"
            },
            {
              "callee": "commit",
              "is_method": true
            },
            {
              "callee": "create_account_with_random_key_signed",
              "is_method": true,
              "receiver_type": "transaction_builder"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "process_transaction",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "process_transaction",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "create_account_transaction"
            },
            {
              "callee": "expect",
              "is_method": true
            },
            {
              "callee": "SigningKey::new_with_algorithm",
              "is_method": false
            },
            {
              "callee": "commit",
              "is_method": true
            },
            {
              "callee": "add_key_verified_with_root",
              "is_method": true,
              "receiver_type": "transaction_builder"
            },
            {
              "callee": "into",
              "is_method": true
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "new_key"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "process_transaction",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "commit",
              "is_method": true
            },
            {
              "callee": "revoke_key",
              "is_method": true,
              "receiver_type": "transaction_builder"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "cloned",
              "is_method": true
            },
            {
              "callee": "get_public_key",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "process_transaction",
              "is_method": true,
              "receiver_type": "prover"
            }
          ],
          "local_variables": [
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "transaction_builder",
              "is_mutable": true
            },
            {
              "name": "register_service_transaction",
              "is_mutable": false
            },
            {
              "name": "create_account_transaction",
              "is_mutable": false
            },
            {
              "name": "proof",
              "is_mutable": false
            },
            {
              "name": "proof",
              "is_mutable": false
            },
            {
              "name": "new_key",
              "is_mutable": false
            },
            {
              "name": "add_key_transaction",
              "is_mutable": false
            },
            {
              "name": "proof",
              "is_mutable": false
            },
            {
              "name": "revoke_transaction",
              "is_mutable": false
            },
            {
              "name": "proof",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
            "name": "test_execute_block_with_invalid_tx",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "create_test_prover",
              "is_method": false
            },
            {
              "callee": "TestTransactionBuilder::new",
              "is_method": false
            },
            {
              "callee": "expect",
              "is_method": true
            },
            {
              "callee": "SigningKey::new_with_algorithm",
              "is_method": false
            },
            {
              "callee": "into",
              "is_method": true
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "new_key_1"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "execute_block",
              "is_method": true,
              "receiver_type": "prover"
            }
          ],
          "local_variables": [
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "tx_builder",
              "is_mutable": true
            },
            {
              "name": "new_key_1",
              "is_mutable": false
            },
            {
              "name": "transactions",
              "is_mutable": false
            },
            {
              "name": "proofs",
              "is_mutable": false
            }
          ],
          "type_references": [
            "VerifyingKey"
          ],
          "macro_invocations": [
            {
              "name": "vec",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
            "name": "test_execute_block",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "create_test_prover",
              "is_method": false
            },
            {
              "callee": "create_mock_transactions",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "execute_block",
              "is_method": true,
              "receiver_type": "prover"
            }
          ],
          "local_variables": [
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "transactions",
              "is_mutable": false
            },
            {
              "name": "proofs",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
            "name": "test_finalize_new_epoch",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "create_test_prover",
              "is_method": false
            },
            {
              "callee": "create_mock_transactions",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "finalize_new_epoch",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "prover"
            }
          ],
          "local_variables": [
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "transactions",
              "is_mutable": false
            },
            {
              "name": "prev_commitment",
              "is_mutable": false
            },
            {
              "name": "new_commitment",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert_ne",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
            "name": "test_restart_sync_from_scratch",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "InMemoryDataAvailabilityLayer::new",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Box::new",
              "is_method": false
            },
            {
              "callee": "InMemoryDatabase::new",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Box::new",
              "is_method": false
            },
            {
              "callee": "InMemoryDatabase::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Config::default_with_key_algorithm",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "db1"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "runner"
            },
            {
              "callee": "create_mock_transactions",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "validate_and_queue_update",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "brx"
            },
            {
              "callee": "is_empty",
              "is_method": true
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "db2"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover2"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "runner"
            },
            {
              "callee": "get_latest_epoch_height",
              "is_method": true
            },
            {
              "callee": "get_db",
              "is_method": true,
              "receiver_type": "prover2"
            },
            {
              "callee": "is_ok",
              "is_method": true,
              "receiver_type": "epoch"
            },
            {
              "callee": "unwrap",
              "is_method": true,
              "receiver_type": "epoch"
            },
            {
              "callee": "tokio::time::sleep",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            }
          ],
          "local_variables": [
            {
              "name": "da_layer",
              "is_mutable": false
            },
            {
              "name": "cfg",
              "is_mutable": true
            },
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "runner",
              "is_mutable": false
            },
            {
              "name": "transactions",
              "is_mutable": false
            },
            {
              "name": "prover2",
              "is_mutable": false
            },
            {
              "name": "runner",
              "is_mutable": false
            },
            {
              "name": "epoch",
              "is_mutable": false
            }
          ],
          "type_references": [
            "Arc",
            "Box"
          ],
          "macro_invocations": [
            {
              "name": "assert_eq",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
            "name": "test_prover_fullnode_commitment_sync_with_racing_transactions",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "InMemoryDataAvailabilityLayer::new_with_epoch_delay",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "Duration::from_secs",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Box::new",
              "is_method": false
            },
            {
              "callee": "InMemoryDatabase::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Config::default_with_key_algorithm",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover_db"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Box::new",
              "is_method": false
            },
            {
              "callee": "InMemoryDatabase::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Config::default_with_key_algorithm",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "fullnode_db"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "prover_handle"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "fullnode"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "fullnode_handle"
            },
            {
              "callee": "tokio::time::sleep",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "unwrap_or",
              "is_method": true
            },
            {
              "callee": "get_last_synced_height",
              "is_method": true
            },
            {
              "callee": "get_db",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap_or",
              "is_method": true
            },
            {
              "callee": "get_last_synced_height",
              "is_method": true
            },
            {
              "callee": "get_db",
              "is_method": true,
              "receiver_type": "fullnode"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_latest_height",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "tokio::time::sleep",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "create_mock_transactions",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "split_at",
              "is_method": true,
              "receiver_type": "all_transactions"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "submit_transactions",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "tokio::time::sleep",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "submit_transactions",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "brx"
            },
            {
              "callee": "is_empty",
              "is_method": true
            },
            {
              "callee": "tokio::time::sleep",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_commitment",
              "is_method": true,
              "receiver_type": "fullnode"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_latest_epoch_height",
              "is_method": true
            },
            {
              "callee": "get_db",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_latest_epoch_height",
              "is_method": true
            },
            {
              "callee": "get_db",
              "is_method": true,
              "receiver_type": "fullnode"
            }
          ],
          "local_variables": [
            {
              "name": "da_layer",
              "is_mutable": false
            },
            {
              "name": "prover_cfg",
              "is_mutable": true
            },
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "fullnode_cfg",
              "is_mutable": true
            },
            {
              "name": "fullnode",
              "is_mutable": false
            },
            {
              "name": "prover_handle",
              "is_mutable": false
            },
            {
              "name": "fullnode_handle",
              "is_mutable": false
            },
            {
              "name": "prover_synced",
              "is_mutable": true
            },
            {
              "name": "fullnode_synced",
              "is_mutable": true
            },
            {
              "name": "prover_height",
              "is_mutable": false
            },
            {
              "name": "fullnode_height",
              "is_mutable": false
            },
            {
              "name": "da_height",
              "is_mutable": false
            },
            {
              "name": "all_transactions",
              "is_mutable": false
            },
            {
              "name": "epoch_found",
              "is_mutable": true
            },
            {
              "name": "prover_commitment",
              "is_mutable": false
            },
            {
              "name": "fullnode_commitment",
              "is_mutable": false
            },
            {
              "name": "prover_epoch",
              "is_mutable": false
            },
            {
              "name": "fullnode_epoch",
              "is_mutable": false
            }
          ],
          "type_references": [
            "Arc",
            "Box"
          ],
          "macro_invocations": [
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "vec",
              "kind": "function-like"
            },
            {
              "name": "vec",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
            "name": "test_load_persisted_state",
            "visibility": "private",
            "is_async": true,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "InMemoryDataAvailabilityLayer::new",
              "is_method": false
            },
            {
              "callee": "Duration::from_millis",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "Box::new",
              "is_method": false
            },
            {
              "callee": "InMemoryDatabase::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Config::default_with_key_algorithm",
              "is_method": false
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "db"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "runner"
            },
            {
              "callee": "create_mock_transactions",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "validate_and_queue_update",
              "is_method": true,
              "receiver_type": "prover"
            },
            {
              "callee": "recv",
              "is_method": true,
              "receiver_type": "brx"
            },
            {
              "callee": "is_empty",
              "is_method": true
            },
            {
              "callee": "Arc::new",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "Prover::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "db"
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "da_layer"
            },
            {
              "callee": "CancellationToken::new",
              "is_method": false
            },
            {
              "callee": "clone",
              "is_method": true,
              "receiver_type": "prover2"
            },
            {
              "callee": "spawn",
              "is_method": false
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "run",
              "is_method": true,
              "receiver_type": "runner"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "get_latest_epoch_height",
              "is_method": true
            },
            {
              "callee": "get_db",
              "is_method": true,
              "receiver_type": "prover2"
            }
          ],
          "local_variables": [
            {
              "name": "da_layer",
              "is_mutable": false
            },
            {
              "name": "cfg",
              "is_mutable": true
            },
            {
              "name": "prover",
              "is_mutable": false
            },
            {
              "name": "runner",
              "is_mutable": false
            },
            {
              "name": "transactions",
              "is_mutable": false
            },
            {
              "name": "prover2",
              "is_mutable": false
            },
            {
              "name": "runner",
              "is_mutable": false
            },
            {
              "name": "epoch",
              "is_mutable": false
            }
          ],
          "type_references": [
            "Box",
            "Arc"
          ],
          "macro_invocations": [
            {
              "name": "assert_eq",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            },
            {
              "name": "assert_eq",
              "kind": "function-like"
            }
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/prover/mod.rs",
      "path": "../crates/node_types/prover/src/prover/mod.rs",
      "relative_path": "crates/node_types/prover/src/prover/mod.rs",
      "file_size": 10163,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/prover/mod.rs#timer",
            "name": "timer",
            "visibility": "private",
            "items": []
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_anyhow_{Context,Result,anyhow}",
            "path": "anyhow :: { Context , Result , anyhow }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_common_{api_{PendingTransaction,PendingTransactionImpl,PrismApi,PrismApiError,types_{AccountResponse,CommitmentResponse,HashedMerkleProof},},transaction_Transaction,}",
            "path": "prism_common :: { api :: { PendingTransaction , PendingTransactionImpl , PrismApi , PrismApiError , types :: { AccountResponse , CommitmentResponse , HashedMerkleProof } , } , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_keys_{CryptoAlgorithm,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_tree_AccountResponse_*",
            "path": "prism_tree :: AccountResponse :: *",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_timer_ProverTokioTimer",
            "path": "timer :: ProverTokioTimer",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_tokio_{sync_RwLock,task_JoinSet}",
            "path": "tokio :: { sync :: RwLock , task :: JoinSet }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_crate_{prover_engine_ProverEngine,sequencer_Sequencer,syncer_Syncer,webserver_{WebServer,WebServerConfig},}",
            "path": "crate :: { prover_engine :: ProverEngine , sequencer :: Sequencer , syncer :: Syncer , webserver :: { WebServer , WebServerConfig } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_da_DataAvailabilityLayer",
            "path": "prism_da :: DataAvailabilityLayer",
            "visibility": "private"
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/node_types/prover/src/prover/mod.rs#DEFAULT_MAX_EPOCHLESS_GAP",
            "name": "DEFAULT_MAX_EPOCHLESS_GAP",
            "visibility": "pub",
            "type_name": "u64"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#SyncerConfig",
            "name": "SyncerConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "verifying_key",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              },
              {
                "name": "start_height",
                "type_name": "u64",
                "visibility": "pub"
              },
              {
                "name": "max_epochless_gap",
                "type_name": "u64",
                "visibility": "pub"
              },
              {
                "name": "prover_enabled",
                "type_name": "bool",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#SequencerConfig",
            "name": "SequencerConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "signing_key",
                "type_name": "SigningKey",
                "visibility": "pub"
              },
              {
                "name": "batcher_enabled",
                "type_name": "bool",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#ProverEngineConfig",
            "name": "ProverEngineConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "recursive_proofs",
                "type_name": "bool",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#Config",
            "name": "Config",
            "visibility": "pub",
            "fields": [
              {
                "name": "syncer",
                "type_name": "SyncerConfig",
                "visibility": "pub"
              },
              {
                "name": "sequencer",
                "type_name": "SequencerConfig",
                "visibility": "pub"
              },
              {
                "name": "prover_engine",
                "type_name": "ProverEngineConfig",
                "visibility": "pub"
              },
              {
                "name": "webserver",
                "type_name": "WebServerConfig",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_Default_Config",
            "target_type": "Config",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { let signing_key = SigningKey :: new_ed25519 () ; Config { syncer : SyncerConfig { verifying_key : signing_key . verifying_key () , start_height : 1 , max_epochless_gap : DEFAULT_MAX_EPOCHLESS_GAP , prover_enabled : true , } , sequencer : SequencerConfig { signing_key , batcher_enabled : true , } , prover_engine : ProverEngineConfig { recursive_proofs : false , } , webserver : WebServerConfig :: default () , } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_Config",
            "target_type": "Config",
            "trait_name": null,
            "items": [
              "# [doc = \" Creates a new Config instance with the specified key algorithm.\"] # [doc = \"\"] # [doc = \" # Arguments\"] # [doc = \" * `algorithm` - The key algorithm to use for signing and verification\"] # [doc = \"\"] # [doc = \" # Returns\"] # [doc = \" A Result containing the Config or an error if key creation fails\"] fn default_with_key_algorithm (algorithm : CryptoAlgorithm) -> Result < Self > { let signing_key = SigningKey :: new_with_algorithm (algorithm) . context (\"Failed to create signing key\") ? ; let mut config = Config :: default () ; config . syncer . verifying_key = signing_key . verifying_key () ; config . sequencer . signing_key = signing_key ; Ok (config) }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#Prover",
            "name": "Prover",
            "visibility": "pub",
            "fields": [
              {
                "name": "cfg",
                "type_name": "Config",
                "visibility": "pub"
              },
              {
                "name": "prover_engine",
                "type_name": "Arc < ProverEngine >",
                "visibility": "private"
              },
              {
                "name": "sequencer",
                "type_name": "Arc < Sequencer >",
                "visibility": "private"
              },
              {
                "name": "syncer",
                "type_name": "Arc < Syncer >",
                "visibility": "private"
              },
              {
                "name": "latest_epoch_da_height",
                "type_name": "Arc < RwLock < u64 > >",
                "visibility": "private"
              },
              {
                "name": "cancellation_token",
                "type_name": "CancellationToken",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_Prover",
            "target_type": "Prover",
            "trait_name": null,
            "items": [
              "pub fn new (db : Arc < Box < dyn Database > > , da : Arc < dyn DataAvailabilityLayer > , cfg : & Config , cancellation_token : CancellationToken ,) -> Result < Prover > { let latest_epoch_da_height = Arc :: new (RwLock :: new (0)) ; let prover_engine = Arc :: new (ProverEngine :: new (& cfg . prover_engine) ?) ; let sequencer = Arc :: new (Sequencer :: new (db . clone () , da . clone () , & cfg . sequencer , latest_epoch_da_height . clone () ,) ?) ; let syncer = Arc :: new (Syncer :: new (da , db , & cfg . syncer , latest_epoch_da_height . clone () , sequencer . clone () , prover_engine . clone () ,)) ; Ok (Prover { cfg : cfg . clone () , prover_engine , sequencer , syncer , latest_epoch_da_height , cancellation_token , }) }",
              "pub fn get_db (& self) -> Arc < Box < dyn Database > > { self . sequencer . get_db () }",
              "pub async fn execute_block (& self , transactions : Vec < Transaction > ,) -> Result < Vec < prism_tree :: proofs :: Proof > > { self . sequencer . execute_block (transactions) . await }",
              "pub async fn finalize_new_epoch (& self , epoch_height : u64 , transactions : Vec < Transaction > , tip_da_height : u64 ,) -> Result < u64 > { self . sequencer . finalize_new_epoch (epoch_height , transactions , & self . prover_engine , tip_da_height ,) . await }",
              "pub async fn validate_and_queue_update (& self , transaction : Transaction) -> Result < () > { self . sequencer . validate_and_queue_update (transaction) . await }",
              "pub fn get_pending_transactions (& self) -> Arc < RwLock < Vec < Transaction > > > { self . sequencer . get_pending_transactions () }",
              "pub async fn process_transaction (& self , transaction : Transaction ,) -> Result < prism_tree :: proofs :: Proof > { self . sequencer . process_transaction (transaction) . await }",
              "pub fn get_da (& self) -> Arc < dyn DataAvailabilityLayer > { self . syncer . get_da () }",
              "pub async fn run (self : Arc < Self >) -> Result < () > { let mut futures = JoinSet :: new () ; let syncer = self . syncer . clone () ; let cancel_token = self . cancellation_token . clone () ; futures . spawn (async move { syncer . start (cancel_token) . await }) ; let sequencer = self . sequencer . clone () ; let cancel_token = self . cancellation_token . clone () ; futures . spawn (async move { sequencer . start (cancel_token) . await }) ; if self . cfg . webserver . enabled { let ws = WebServer :: new (self . cfg . webserver . clone () , self . clone ()) ; let cancel_token = self . cancellation_token . clone () ; futures . spawn (async move { ws . start (cancel_token) . await }) ; } let exit_result = if let Some (result) = futures . join_next () . await { match result { Ok (service_result) => match service_result { Ok (_) => { info ! (\"Service exited gracefully, shutting down other components\") ; self . cancellation_token . cancel () ; Ok (()) } Err (service_error) => { error ! (\"Service exited with error: {:?}, shutting down other components\" , service_error) ; self . cancellation_token . cancel () ; Err (service_error) } } , Err (join_error) => { error ! (\"Task join error: {:?}, shutting down other components\" , join_error) ; self . cancellation_token . cancel () ; Err (anyhow ! (\"Task join error: {}\" , join_error)) } } } else { error ! (\"No futures in join set, shutting down\") ; Ok (()) } ; while let Some (result) = futures . join_next () . await { match result { Ok (Ok (_)) => debug ! (\"Component shut down gracefully\") , Ok (Err (e)) => warn ! (\"Component shut down with error: {:?}\" , e) , Err (e) => warn ! (\"Component join error during shutdown: {:?}\" , e) , } } info ! (\"Prover shutdown complete\") ; exit_result }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_PrismApi_Prover",
            "target_type": "Prover",
            "trait_name": "PrismApi",
            "items": [
              "type Timer = ProverTokioTimer ;",
              "async fn get_account (& self , id : & str) -> Result < AccountResponse , PrismApiError > { let acc_response = match self . sequencer . get_account (id) . await ? { Found (account , inclusion_proof) => { let hashed_inclusion_proof = inclusion_proof . hashed () ; AccountResponse { account : Some (* account) , proof : HashedMerkleProof { leaf : hashed_inclusion_proof . leaf , siblings : hashed_inclusion_proof . siblings , } , } } NotFound (non_inclusion_proof) => { let hashed_non_inclusion = non_inclusion_proof . hashed () ; AccountResponse { account : None , proof : HashedMerkleProof { leaf : hashed_non_inclusion . leaf , siblings : hashed_non_inclusion . siblings , } , } } } ; Ok (acc_response) }",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > { let commitment = self . sequencer . get_commitment () . await ? ; Ok (CommitmentResponse { commitment }) }",
              "async fn post_transaction (& self , transaction : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . sequencer . validate_and_queue_update (transaction . clone ()) . await ? ; Ok (PendingTransactionImpl :: new (self , transaction)) }"
            ],
            "generics": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/prover/mod.rs#tests",
            "name": "tests",
            "visibility": "private",
            "items": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/prover/mod.rs#timer",
            "name": "timer",
            "visibility": "private",
            "items": []
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_anyhow_{Context,Result,anyhow}",
            "path": "anyhow :: { Context , Result , anyhow }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_common_{api_{PendingTransaction,PendingTransactionImpl,PrismApi,PrismApiError,types_{AccountResponse,CommitmentResponse,HashedMerkleProof},},transaction_Transaction,}",
            "path": "prism_common :: { api :: { PendingTransaction , PendingTransactionImpl , PrismApi , PrismApiError , types :: { AccountResponse , CommitmentResponse , HashedMerkleProof } , } , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_keys_{CryptoAlgorithm,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_tree_AccountResponse_*",
            "path": "prism_tree :: AccountResponse :: *",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_timer_ProverTokioTimer",
            "path": "timer :: ProverTokioTimer",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_tokio_{sync_RwLock,task_JoinSet}",
            "path": "tokio :: { sync :: RwLock , task :: JoinSet }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_tokio_util_sync_CancellationToken",
            "path": "tokio_util :: sync :: CancellationToken",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_crate_{prover_engine_ProverEngine,sequencer_Sequencer,syncer_Syncer,webserver_{WebServer,WebServerConfig},}",
            "path": "crate :: { prover_engine :: ProverEngine , sequencer :: Sequencer , syncer :: Syncer , webserver :: { WebServer , WebServerConfig } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover/mod.rs#use_prism_da_DataAvailabilityLayer",
            "path": "prism_da :: DataAvailabilityLayer",
            "visibility": "private"
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/node_types/prover/src/prover/mod.rs#DEFAULT_MAX_EPOCHLESS_GAP",
            "name": "DEFAULT_MAX_EPOCHLESS_GAP",
            "visibility": "pub",
            "type_name": "u64"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#SyncerConfig",
            "name": "SyncerConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "verifying_key",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              },
              {
                "name": "start_height",
                "type_name": "u64",
                "visibility": "pub"
              },
              {
                "name": "max_epochless_gap",
                "type_name": "u64",
                "visibility": "pub"
              },
              {
                "name": "prover_enabled",
                "type_name": "bool",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#SequencerConfig",
            "name": "SequencerConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "signing_key",
                "type_name": "SigningKey",
                "visibility": "pub"
              },
              {
                "name": "batcher_enabled",
                "type_name": "bool",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#ProverEngineConfig",
            "name": "ProverEngineConfig",
            "visibility": "pub",
            "fields": [
              {
                "name": "recursive_proofs",
                "type_name": "bool",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#Config",
            "name": "Config",
            "visibility": "pub",
            "fields": [
              {
                "name": "syncer",
                "type_name": "SyncerConfig",
                "visibility": "pub"
              },
              {
                "name": "sequencer",
                "type_name": "SequencerConfig",
                "visibility": "pub"
              },
              {
                "name": "prover_engine",
                "type_name": "ProverEngineConfig",
                "visibility": "pub"
              },
              {
                "name": "webserver",
                "type_name": "WebServerConfig",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_Default_Config",
            "target_type": "Config",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { let signing_key = SigningKey :: new_ed25519 () ; Config { syncer : SyncerConfig { verifying_key : signing_key . verifying_key () , start_height : 1 , max_epochless_gap : DEFAULT_MAX_EPOCHLESS_GAP , prover_enabled : true , } , sequencer : SequencerConfig { signing_key , batcher_enabled : true , } , prover_engine : ProverEngineConfig { recursive_proofs : false , } , webserver : WebServerConfig :: default () , } }"
            ],
            "generics": []
          },
          "type_references": [
            "Config"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_Config",
            "target_type": "Config",
            "trait_name": null,
            "items": [
              "# [doc = \" Creates a new Config instance with the specified key algorithm.\"] # [doc = \"\"] # [doc = \" # Arguments\"] # [doc = \" * `algorithm` - The key algorithm to use for signing and verification\"] # [doc = \"\"] # [doc = \" # Returns\"] # [doc = \" A Result containing the Config or an error if key creation fails\"] fn default_with_key_algorithm (algorithm : CryptoAlgorithm) -> Result < Self > { let signing_key = SigningKey :: new_with_algorithm (algorithm) . context (\"Failed to create signing key\") ? ; let mut config = Config :: default () ; config . syncer . verifying_key = signing_key . verifying_key () ; config . sequencer . signing_key = signing_key ; Ok (config) }"
            ],
            "generics": []
          },
          "type_references": [
            "Config"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover/mod.rs#Prover",
            "name": "Prover",
            "visibility": "pub",
            "fields": [
              {
                "name": "cfg",
                "type_name": "Config",
                "visibility": "pub"
              },
              {
                "name": "prover_engine",
                "type_name": "Arc < ProverEngine >",
                "visibility": "private"
              },
              {
                "name": "sequencer",
                "type_name": "Arc < Sequencer >",
                "visibility": "private"
              },
              {
                "name": "syncer",
                "type_name": "Arc < Syncer >",
                "visibility": "private"
              },
              {
                "name": "latest_epoch_da_height",
                "type_name": "Arc < RwLock < u64 > >",
                "visibility": "private"
              },
              {
                "name": "cancellation_token",
                "type_name": "CancellationToken",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_Prover",
            "target_type": "Prover",
            "trait_name": null,
            "items": [
              "pub fn new (db : Arc < Box < dyn Database > > , da : Arc < dyn DataAvailabilityLayer > , cfg : & Config , cancellation_token : CancellationToken ,) -> Result < Prover > { let latest_epoch_da_height = Arc :: new (RwLock :: new (0)) ; let prover_engine = Arc :: new (ProverEngine :: new (& cfg . prover_engine) ?) ; let sequencer = Arc :: new (Sequencer :: new (db . clone () , da . clone () , & cfg . sequencer , latest_epoch_da_height . clone () ,) ?) ; let syncer = Arc :: new (Syncer :: new (da , db , & cfg . syncer , latest_epoch_da_height . clone () , sequencer . clone () , prover_engine . clone () ,)) ; Ok (Prover { cfg : cfg . clone () , prover_engine , sequencer , syncer , latest_epoch_da_height , cancellation_token , }) }",
              "pub fn get_db (& self) -> Arc < Box < dyn Database > > { self . sequencer . get_db () }",
              "pub async fn execute_block (& self , transactions : Vec < Transaction > ,) -> Result < Vec < prism_tree :: proofs :: Proof > > { self . sequencer . execute_block (transactions) . await }",
              "pub async fn finalize_new_epoch (& self , epoch_height : u64 , transactions : Vec < Transaction > , tip_da_height : u64 ,) -> Result < u64 > { self . sequencer . finalize_new_epoch (epoch_height , transactions , & self . prover_engine , tip_da_height ,) . await }",
              "pub async fn validate_and_queue_update (& self , transaction : Transaction) -> Result < () > { self . sequencer . validate_and_queue_update (transaction) . await }",
              "pub fn get_pending_transactions (& self) -> Arc < RwLock < Vec < Transaction > > > { self . sequencer . get_pending_transactions () }",
              "pub async fn process_transaction (& self , transaction : Transaction ,) -> Result < prism_tree :: proofs :: Proof > { self . sequencer . process_transaction (transaction) . await }",
              "pub fn get_da (& self) -> Arc < dyn DataAvailabilityLayer > { self . syncer . get_da () }",
              "pub async fn run (self : Arc < Self >) -> Result < () > { let mut futures = JoinSet :: new () ; let syncer = self . syncer . clone () ; let cancel_token = self . cancellation_token . clone () ; futures . spawn (async move { syncer . start (cancel_token) . await }) ; let sequencer = self . sequencer . clone () ; let cancel_token = self . cancellation_token . clone () ; futures . spawn (async move { sequencer . start (cancel_token) . await }) ; if self . cfg . webserver . enabled { let ws = WebServer :: new (self . cfg . webserver . clone () , self . clone ()) ; let cancel_token = self . cancellation_token . clone () ; futures . spawn (async move { ws . start (cancel_token) . await }) ; } let exit_result = if let Some (result) = futures . join_next () . await { match result { Ok (service_result) => match service_result { Ok (_) => { info ! (\"Service exited gracefully, shutting down other components\") ; self . cancellation_token . cancel () ; Ok (()) } Err (service_error) => { error ! (\"Service exited with error: {:?}, shutting down other components\" , service_error) ; self . cancellation_token . cancel () ; Err (service_error) } } , Err (join_error) => { error ! (\"Task join error: {:?}, shutting down other components\" , join_error) ; self . cancellation_token . cancel () ; Err (anyhow ! (\"Task join error: {}\" , join_error)) } } } else { error ! (\"No futures in join set, shutting down\") ; Ok (()) } ; while let Some (result) = futures . join_next () . await { match result { Ok (Ok (_)) => debug ! (\"Component shut down gracefully\") , Ok (Err (e)) => warn ! (\"Component shut down with error: {:?}\" , e) , Err (e) => warn ! (\"Component join error during shutdown: {:?}\" , e) , } } info ! (\"Prover shutdown complete\") ; exit_result }"
            ],
            "generics": []
          },
          "type_references": [
            "Prover"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover/mod.rs#impl_PrismApi_Prover",
            "target_type": "Prover",
            "trait_name": "PrismApi",
            "items": [
              "type Timer = ProverTokioTimer ;",
              "async fn get_account (& self , id : & str) -> Result < AccountResponse , PrismApiError > { let acc_response = match self . sequencer . get_account (id) . await ? { Found (account , inclusion_proof) => { let hashed_inclusion_proof = inclusion_proof . hashed () ; AccountResponse { account : Some (* account) , proof : HashedMerkleProof { leaf : hashed_inclusion_proof . leaf , siblings : hashed_inclusion_proof . siblings , } , } } NotFound (non_inclusion_proof) => { let hashed_non_inclusion = non_inclusion_proof . hashed () ; AccountResponse { account : None , proof : HashedMerkleProof { leaf : hashed_non_inclusion . leaf , siblings : hashed_non_inclusion . siblings , } , } } } ; Ok (acc_response) }",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > { let commitment = self . sequencer . get_commitment () . await ? ; Ok (CommitmentResponse { commitment }) }",
              "async fn post_transaction (& self , transaction : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . sequencer . validate_and_queue_update (transaction . clone ()) . await ? ; Ok (PendingTransactionImpl :: new (self , transaction)) }"
            ],
            "generics": []
          },
          "type_references": [
            "Prover"
          ]
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/node_types/prover/src/prover/mod.rs#tests",
            "name": "tests",
            "visibility": "private",
            "items": []
          }
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/node_types/prover/src/prover_engine.rs",
      "path": "../crates/node_types/prover/src/prover_engine.rs",
      "relative_path": "crates/node_types/prover/src/prover_engine.rs",
      "file_size": 6137,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_anyhow_{Result,anyhow}",
            "path": "anyhow :: { Result , anyhow }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_prism_tree_proofs_Batch",
            "path": "prism_tree :: proofs :: Batch",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_sp1_sdk_{EnvProver,HashableKeyas_,ProverClient,SP1Proof,SP1ProofWithPublicValues,SP1ProvingKey,SP1Stdin,SP1VerifyingKey,}",
            "path": "sp1_sdk :: { EnvProver , HashableKey as _ , ProverClient , SP1Proof , SP1ProofWithPublicValues , SP1ProvingKey , SP1Stdin , SP1VerifyingKey , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_tokio_sync_RwLock",
            "path": "tokio :: sync :: RwLock",
            "visibility": "private"
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/node_types/prover/src/prover_engine.rs#BASE_PRISM_ELF",
            "name": "BASE_PRISM_ELF",
            "visibility": "pub",
            "type_name": "& [u8]"
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/node_types/prover/src/prover_engine.rs#RECURSIVE_PRISM_ELF",
            "name": "RECURSIVE_PRISM_ELF",
            "visibility": "pub",
            "type_name": "& [u8]"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover_engine.rs#ProverEngine",
            "name": "ProverEngine",
            "visibility": "pub",
            "fields": [
              {
                "name": "base_prover_client",
                "type_name": "Arc < RwLock < EnvProver > >",
                "visibility": "private"
              },
              {
                "name": "base_proving_key",
                "type_name": "SP1ProvingKey",
                "visibility": "private"
              },
              {
                "name": "base_verifying_key",
                "type_name": "SP1VerifyingKey",
                "visibility": "private"
              },
              {
                "name": "recursive_prover_client",
                "type_name": "Arc < RwLock < EnvProver > >",
                "visibility": "private"
              },
              {
                "name": "recursive_proving_key",
                "type_name": "SP1ProvingKey",
                "visibility": "private"
              },
              {
                "name": "recursive_verifying_key",
                "type_name": "SP1VerifyingKey",
                "visibility": "private"
              },
              {
                "name": "recursive_proofs_enabled",
                "type_name": "bool",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover_engine.rs#impl_ProverEngine",
            "target_type": "ProverEngine",
            "trait_name": null,
            "items": [
              "pub fn new (config : & crate :: prover :: ProverEngineConfig) -> Result < Self > { let base_prover_client = ProverClient :: from_env () ; let recursive_prover_client = ProverClient :: from_env () ; let (base_pk , base_vk) = base_prover_client . setup (BASE_PRISM_ELF) ; let (recursive_pk , recursive_vk) = recursive_prover_client . setup (RECURSIVE_PRISM_ELF) ; Ok (ProverEngine { base_proving_key : base_pk , base_verifying_key : base_vk , recursive_proving_key : recursive_pk , recursive_verifying_key : recursive_vk , base_prover_client : Arc :: new (RwLock :: new (base_prover_client)) , recursive_prover_client : Arc :: new (RwLock :: new (recursive_prover_client)) , recursive_proofs_enabled : config . recursive_proofs , }) }",
              "pub async fn prove_epoch (& self , epoch_height : u64 , batch : & Batch , db : & Arc < Box < dyn Database > > ,) -> Result < (SP1ProofWithPublicValues , SP1ProofWithPublicValues) > { let (proof , compressed_proof , client , verifying_key) = if epoch_height == 0 || ! self . recursive_proofs_enabled { self . prove_with_base_prover (epoch_height , batch) . await ? } else { self . prove_with_recursive_prover (epoch_height , batch , db) . await ? } ; client . verify (& proof , verifying_key) ? ; info ! (\"verified proof for epoch {}\" , epoch_height) ; Ok ((proof , compressed_proof)) }",
              "async fn prove_with_base_prover (& self , epoch_height : u64 , batch : & Batch ,) -> Result < (SP1ProofWithPublicValues , SP1ProofWithPublicValues , tokio :: sync :: RwLockReadGuard < '_ , EnvProver > , & SP1VerifyingKey ,) > { let mut stdin = SP1Stdin :: new () ; stdin . write (batch) ; let client = self . base_prover_client . read () . await ; info ! (\"generating proof for epoch {}\" , epoch_height) ; let proof = client . prove (& self . base_proving_key , & stdin) . groth16 () . run () ? ; info ! (\"successfully generated base proof for epoch {}\" , epoch_height) ; let compressed_proof = client . prove (& self . base_proving_key , & stdin) . compressed () . run () ? ; info ! (\"successfully generated compressed proof for epoch {}\" , epoch_height) ; Ok ((proof , compressed_proof , client , & self . base_verifying_key)) }",
              "async fn prove_with_recursive_prover (& self , epoch_height : u64 , batch : & Batch , db : & Arc < Box < dyn Database > > ,) -> Result < (SP1ProofWithPublicValues , SP1ProofWithPublicValues , tokio :: sync :: RwLockReadGuard < '_ , EnvProver > , & SP1VerifyingKey ,) > { let prev_epoch = match db . get_latest_epoch () { Ok (epoch) => epoch , Err (_) => { return Err (anyhow ! (\"Previous epoch not found for recursive verification at height {}\" , epoch_height - 1)) ; } } ; let vk_to_use = if prev_epoch . height == 0 { self . base_verifying_key . clone () } else { self . recursive_verifying_key . clone () } ; let mut stdin = SP1Stdin :: new () ; let compressed_proof = match prev_epoch . compressed_proof . proof { SP1Proof :: Compressed (proof) => proof , _ => return Err (anyhow ! (\"Invalid proof type: expected compressed proof\")) , } ; stdin . write_proof (* compressed_proof , vk_to_use . clone () . vk) ; stdin . write_vec (prev_epoch . public_values . to_vec ()) ; stdin . write (& vk_to_use . hash_u32 ()) ; stdin . write (batch) ; let client = self . recursive_prover_client . read () . await ; info ! (\"generating recursive proof for epoch at height {}\" , epoch_height) ; let proof = client . prove (& self . recursive_proving_key , & stdin) . groth16 () . run () ? ; info ! (\"successfully generated recursive proof for epoch {}\" , epoch_height) ; let compressed_proof = client . prove (& self . recursive_proving_key , & stdin) . compressed () . run () ? ; info ! (\"successfully generated recursive compressed proof for epoch {}\" , epoch_height) ; Ok ((proof , compressed_proof , client , & self . recursive_verifying_key ,)) }",
              "pub fn get_verifying_key (& self , epoch_height : u64) -> & SP1VerifyingKey { if epoch_height == 0 || ! self . recursive_proofs_enabled { & self . base_verifying_key } else { & self . recursive_verifying_key } }",
              "pub async fn verify_epoch_proof (& self , epoch_height : u64 , proof : & SP1ProofWithPublicValues ,) -> Result < () > { let client = if epoch_height == 0 || ! self . recursive_proofs_enabled { self . base_prover_client . read () . await } else { self . recursive_prover_client . read () . await } ; let verifying_key = self . get_verifying_key (epoch_height) ; client . verify (proof , verifying_key) ? ; Ok (()) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_anyhow_{Result,anyhow}",
            "path": "anyhow :: { Result , anyhow }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_prism_storage_database_Database",
            "path": "prism_storage :: database :: Database",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_prism_tree_proofs_Batch",
            "path": "prism_tree :: proofs :: Batch",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_sp1_sdk_{EnvProver,HashableKeyas_,ProverClient,SP1Proof,SP1ProofWithPublicValues,SP1ProvingKey,SP1Stdin,SP1VerifyingKey,}",
            "path": "sp1_sdk :: { EnvProver , HashableKey as _ , ProverClient , SP1Proof , SP1ProofWithPublicValues , SP1ProvingKey , SP1Stdin , SP1VerifyingKey , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_std_sync_Arc",
            "path": "std :: sync :: Arc",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/node_types/prover/src/prover_engine.rs#use_tokio_sync_RwLock",
            "path": "tokio :: sync :: RwLock",
            "visibility": "private"
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/node_types/prover/src/prover_engine.rs#BASE_PRISM_ELF",
            "name": "BASE_PRISM_ELF",
            "visibility": "pub",
            "type_name": "& [u8]"
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/node_types/prover/src/prover_engine.rs#RECURSIVE_PRISM_ELF",
            "name": "RECURSIVE_PRISM_ELF",
            "visibility": "pub",
            "type_name": "& [u8]"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/node_types/prover/src/prover_engine.rs#ProverEngine",
            "name": "ProverEngine",
            "visibility": "pub",
            "fields": [
              {
                "name": "base_prover_client",
                "type_name": "Arc < RwLock < EnvProver > >",
                "visibility": "private"
              },
              {
                "name": "base_proving_key",
                "type_name": "SP1ProvingKey",
                "visibility": "private"
              },
              {
                "name": "base_verifying_key",
                "type_name": "SP1VerifyingKey",
                "visibility": "private"
              },
              {
                "name": "recursive_prover_client",
                "type_name": "Arc < RwLock < EnvProver > >",
                "visibility": "private"
              },
              {
                "name": "recursive_proving_key",
                "type_name": "SP1ProvingKey",
                "visibility": "private"
              },
              {
                "name": "recursive_verifying_key",
                "type_name": "SP1VerifyingKey",
                "visibility": "private"
              },
              {
                "name": "recursive_proofs_enabled",
                "type_name": "bool",
                "visibility": "private"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/node_types/prover/src/prover_engine.rs#impl_ProverEngine",
            "target_type": "ProverEngine",
            "trait_name": null,
            "items": [
              "pub fn new (config : & crate :: prover :: ProverEngineConfig) -> Result < Self > { let base_prover_client = ProverClient :: from_env () ; let recursive_prover_client = ProverClient :: from_env () ; let (base_pk , base_vk) = base_prover_client . setup (BASE_PRISM_ELF) ; let (recursive_pk , recursive_vk) = recursive_prover_client . setup (RECURSIVE_PRISM_ELF) ; Ok (ProverEngine { base_proving_key : base_pk , base_verifying_key : base_vk , recursive_proving_key : recursive_pk , recursive_verifying_key : recursive_vk , base_prover_client : Arc :: new (RwLock :: new (base_prover_client)) , recursive_prover_client : Arc :: new (RwLock :: new (recursive_prover_client)) , recursive_proofs_enabled : config . recursive_proofs , }) }",
              "pub async fn prove_epoch (& self , epoch_height : u64 , batch : & Batch , db : & Arc < Box < dyn Database > > ,) -> Result < (SP1ProofWithPublicValues , SP1ProofWithPublicValues) > { let (proof , compressed_proof , client , verifying_key) = if epoch_height == 0 || ! self . recursive_proofs_enabled { self . prove_with_base_prover (epoch_height , batch) . await ? } else { self . prove_with_recursive_prover (epoch_height , batch , db) . await ? } ; client . verify (& proof , verifying_key) ? ; info ! (\"verified proof for epoch {}\" , epoch_height) ; Ok ((proof , compressed_proof)) }",
              "async fn prove_with_base_prover (& self , epoch_height : u64 , batch : & Batch ,) -> Result < (SP1ProofWithPublicValues , SP1ProofWithPublicValues , tokio :: sync :: RwLockReadGuard < '_ , EnvProver > , & SP1VerifyingKey ,) > { let mut stdin = SP1Stdin :: new () ; stdin . write (batch) ; let client = self . base_prover_client . read () . await ; info ! (\"generating proof for epoch {}\" , epoch_height) ; let proof = client . prove (& self . base_proving_key , & stdin) . groth16 () . run () ? ; info ! (\"successfully generated base proof for epoch {}\" , epoch_height) ; let compressed_proof = client . prove (& self . base_proving_key , & stdin) . compressed () . run () ? ; info ! (\"successfully generated compressed proof for epoch {}\" , epoch_height) ; Ok ((proof , compressed_proof , client , & self . base_verifying_key)) }",
              "async fn prove_with_recursive_prover (& self , epoch_height : u64 , batch : & Batch , db : & Arc < Box < dyn Database > > ,) -> Result < (SP1ProofWithPublicValues , SP1ProofWithPublicValues , tokio :: sync :: RwLockReadGuard < '_ , EnvProver > , & SP1VerifyingKey ,) > { let prev_epoch = match db . get_latest_epoch () { Ok (epoch) => epoch , Err (_) => { return Err (anyhow ! (\"Previous epoch not found for recursive verification at height {}\" , epoch_height - 1)) ; } } ; let vk_to_use = if prev_epoch . height == 0 { self . base_verifying_key . clone () } else { self . recursive_verifying_key . clone () } ; let mut stdin = SP1Stdin :: new () ; let compressed_proof = match prev_epoch . compressed_proof . proof { SP1Proof :: Compressed (proof) => proof , _ => return Err (anyhow ! (\"Invalid proof type: expected compressed proof\")) , } ; stdin . write_proof (* compressed_proof , vk_to_use . clone () . vk) ; stdin . write_vec (prev_epoch . public_values . to_vec ()) ; stdin . write (& vk_to_use . hash_u32 ()) ; stdin . write (batch) ; let client = self . recursive_prover_client . read () . await ; info ! (\"generating recursive proof for epoch at height {}\" , epoch_height) ; let proof = client . prove (& self . recursive_proving_key , & stdin) . groth16 () . run () ? ; info ! (\"successfully generated recursive proof for epoch {}\" , epoch_height) ; let compressed_proof = client . prove (& self . recursive_proving_key , & stdin) . compressed () . run () ? ; info ! (\"successfully generated recursive compressed proof for epoch {}\" , epoch_height) ; Ok ((proof , compressed_proof , client , & self . recursive_verifying_key ,)) }",
              "pub fn get_verifying_key (& self , epoch_height : u64) -> & SP1VerifyingKey { if epoch_height == 0 || ! self . recursive_proofs_enabled { & self . base_verifying_key } else { & self . recursive_verifying_key } }",
              "pub async fn verify_epoch_proof (& self , epoch_height : u64 , proof : & SP1ProofWithPublicValues ,) -> Result < () > { let client = if epoch_height == 0 || ! self . recursive_proofs_enabled { self . base_prover_client . read () . await } else { self . recursive_prover_client . read () . await } ; let verifying_key = self . get_verifying_key (epoch_height) ; client . verify (proof , verifying_key) ? ; Ok (()) }"
            ],
            "generics": []
          },
          "type_references": [
            "ProverEngine"
          ]
        }
      ]
    }
  ],
  "cross_references": [
    {
      "from_id": "crates/node_types/prover/src/tx_buffer.rs",
      "to_id": "prism_common :: transaction :: Transaction",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/tx_buffer.rs",
      "to_id": "std :: collections :: BTreeMap",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "crate :: Prover",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "anyhow :: { Result , bail }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "axum :: { Json , extract :: State , http :: StatusCode , response :: IntoResponse }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "prism_common :: { api :: { PrismApi , types :: { AccountRequest , AccountResponse , CommitmentResponse } , } , transaction :: Transaction , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "serde :: { Deserialize , Serialize }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "std :: { net :: SocketAddr , sync :: Arc }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "tokio :: net :: TcpListener",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "tokio_util :: sync :: CancellationToken",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "tower_http :: cors :: CorsLayer",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "utoipa :: { OpenApi , openapi :: { Info , OpenApiBuilder } , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "utoipa_axum :: { router :: OpenApiRouter , routes }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs",
      "to_id": "utoipa_swagger_ui :: SwaggerUi",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#WebServerConfig",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#WebServerConfig",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#WebServerConfig",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#WebServerConfig",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#impl_Default_WebServerConfig",
      "to_id": "trait:Default",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#ApiDoc",
      "to_id": "trait:OpenApi",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#post_transaction",
      "to_id": "validate_and_queue_update",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#post_transaction",
      "to_id": "into_response",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#post_transaction",
      "to_id": "into_response",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_account",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_account",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_account",
      "to_id": "into_response",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_account",
      "to_id": "into_response",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_account",
      "to_id": "Json",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "to_id": "into_response",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "to_id": "Json",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "to_id": "into_response",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/lib.rs",
      "to_id": "prover :: { Config , Prover , ProverEngineConfig , SequencerConfig , SyncerConfig }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/lib.rs",
      "to_id": "webserver :: WebServerConfig",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "anyhow :: { Context , Result , bail }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "jmt :: KeyHash",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "prism_common :: { account :: Account , digest :: Digest , operation :: Operation , transaction :: Transaction , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "prism_da :: { DataAvailabilityLayer , FinalizedEpoch }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "prism_keys :: SigningKey",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "prism_storage :: database :: Database",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "prism_tree :: { AccountResponse :: * , hasher :: TreeHasher , key_directory_tree :: KeyDirectoryTree , proofs :: Proof , snarkable_tree :: SnarkableTree , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "std :: sync :: Arc",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "tokio :: sync :: RwLock",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "tokio_util :: sync :: CancellationToken",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs",
      "to_id": "crate :: prover_engine :: ProverEngine",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/sequencer.rs#Sequencer",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "anyhow :: { Context , Result , anyhow }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "prism_common :: transaction :: Transaction",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "prism_da :: { DataAvailabilityLayer , FinalizedEpoch }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "prism_keys :: VerifyingKey",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "prism_storage :: database :: Database",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "prism_telemetry_registry :: metrics_registry :: get_metrics",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "std :: sync :: Arc",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "tokio :: sync :: { RwLock , broadcast }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "tokio_util :: sync :: CancellationToken",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs",
      "to_id": "crate :: { prover_engine :: ProverEngine , sequencer :: Sequencer , tx_buffer :: TxBuffer }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/syncer.rs#Syncer",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/timer.rs",
      "to_id": "std :: { future :: Future , time :: Duration }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/timer.rs",
      "to_id": "prism_common :: api :: PrismApiTimer",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/timer.rs#impl_PrismApiTimer_ProverTokioTimer",
      "to_id": "trait:PrismApiTimer",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "super :: *",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "prism_common :: test_transaction_builder :: TestTransactionBuilder",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "prism_tree :: proofs :: Proof",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "std :: { self , sync :: Arc , time :: Duration }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "tokio :: spawn",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "tokio_util :: sync :: CancellationToken",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "prism_da :: memory :: InMemoryDataAvailabilityLayer",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs",
      "to_id": "prism_storage :: inmemory :: InMemoryDatabase",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "InMemoryDataAvailabilityLayer::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Box::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "InMemoryDatabase::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Config::default_with_key_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "to_id": "TestTransactionBuilder::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "subscribe_to_heights",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "get_da",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "finalize_new_epoch",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "get_finalized_epoch",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "get_da",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "first",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "read",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "get_finalized_epoch",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "get_da",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_posts_epoch_after_max_gap",
      "to_id": "first",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "TestTransactionBuilder::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "commit",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "register_service_with_random_keys",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "validate_and_queue_update",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "validate_and_queue_update",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "get_pending_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_validate_and_queue_update",
      "to_id": "read",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "TestTransactionBuilder::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "commit",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "register_service_with_random_keys",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "commit",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "create_account_with_random_key_signed",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "process_transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "process_transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "expect",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "SigningKey::new_with_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "commit",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "add_key_verified_with_root",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "into",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "process_transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "commit",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "revoke_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "cloned",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "get_public_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_process_transactions",
      "to_id": "process_transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "TestTransactionBuilder::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "expect",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "SigningKey::new_with_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "into",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block_with_invalid_tx",
      "to_id": "execute_block",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_execute_block",
      "to_id": "execute_block",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_test_prover",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "finalize_new_epoch",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_finalize_new_epoch",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "InMemoryDataAvailabilityLayer::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Box::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "InMemoryDatabase::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Box::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "InMemoryDatabase::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Config::default_with_key_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "validate_and_queue_update",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "is_empty",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "get_latest_epoch_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "get_db",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "is_ok",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "tokio::time::sleep",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_restart_sync_from_scratch",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "InMemoryDataAvailabilityLayer::new_with_epoch_delay",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Duration::from_secs",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Box::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "InMemoryDatabase::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Config::default_with_key_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Box::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "InMemoryDatabase::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Config::default_with_key_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "tokio::time::sleep",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap_or",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_last_synced_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_db",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap_or",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_last_synced_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_db",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_latest_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "tokio::time::sleep",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "split_at",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "submit_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "tokio::time::sleep",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "submit_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "is_empty",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "tokio::time::sleep",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "crates/node_types/prover/src/webserver.rs#get_commitment",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_latest_epoch_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_db",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_latest_epoch_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_prover_fullnode_commitment_sync_with_racing_transactions",
      "to_id": "get_db",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "InMemoryDataAvailabilityLayer::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Duration::from_millis",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Box::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "InMemoryDatabase::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Config::default_with_key_algorithm",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "crates/node_types/prover/src/prover/tests/mod.rs#create_mock_transactions",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "validate_and_queue_update",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "recv",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "is_empty",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Arc::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "Prover::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "CancellationToken::new",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "clone",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "spawn",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "run",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "get_latest_epoch_height",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/tests/mod.rs#test_load_persisted_state",
      "to_id": "get_db",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "anyhow :: { Context , Result , anyhow }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "async_trait :: async_trait",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "prism_common :: { api :: { PendingTransaction , PendingTransactionImpl , PrismApi , PrismApiError , types :: { AccountResponse , CommitmentResponse , HashedMerkleProof } , } , transaction :: Transaction , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "prism_storage :: database :: Database",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "prism_tree :: AccountResponse :: *",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "std :: sync :: Arc",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "timer :: ProverTokioTimer",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "tokio :: { sync :: RwLock , task :: JoinSet }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "tokio_util :: sync :: CancellationToken",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "crate :: { prover_engine :: ProverEngine , sequencer :: Sequencer , syncer :: Syncer , webserver :: { WebServer , WebServerConfig } , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs",
      "to_id": "prism_da :: DataAvailabilityLayer",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs#SyncerConfig",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs#SequencerConfig",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs#ProverEngineConfig",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs#Config",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs#impl_Default_Config",
      "to_id": "trait:Default",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/node_types/prover/src/prover/mod.rs#impl_PrismApi_Prover",
      "to_id": "trait:PrismApi",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs",
      "to_id": "anyhow :: { Result , anyhow }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs",
      "to_id": "prism_storage :: database :: Database",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs",
      "to_id": "prism_tree :: proofs :: Batch",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs",
      "to_id": "sp1_sdk :: { EnvProver , HashableKey as _ , ProverClient , SP1Proof , SP1ProofWithPublicValues , SP1ProvingKey , SP1Stdin , SP1VerifyingKey , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs",
      "to_id": "std :: sync :: Arc",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs",
      "to_id": "tokio :: sync :: RwLock",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/node_types/prover/src/prover_engine.rs#ProverEngine",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    }
  ],
  "total_files": 9,
  "successfully_parsed": 9,
  "failed_files": [],
  "stats": {
    "total_functions": 14,
    "total_structs": 13,
    "total_enums": 0,
    "total_traits": 0,
    "total_impls": 11,
    "total_tests": 0,
    "total_function_calls": 272,
    "total_derives": 12,
    "total_macro_uses": 27
  }
}