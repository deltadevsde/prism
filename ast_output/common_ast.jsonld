{
  "@context": {
    "@version": 1.1,
    "@vocab": "https://schema.org/",
    "attributes": "rust:attributes",
    "crate": "https://w3id.org/rust/crate/",
    "crate_name": "name",
    "crate_path": "rust:cratePath",
    "cross_references": "rust:crossReferences",
    "dcterms": "http://purl.org/dc/terms/",
    "derives": "rust:derives",
    "edge_type": "rust:edgeType",
    "edges": "rust:edges",
    "failed_files": "rust:failedFiles",
    "fields": "rust:fields",
    "file_size": "contentSize",
    "files": "hasPart",
    "function_calls": "rust:functionCalls",
    "generics": "rust:generics",
    "items": "hasPart",
    "label": "rdfs:label",
    "last_modified": "dateModified",
    "local_variables": "rust:localVariables",
    "macro_invocations": "rust:macroInvocations",
    "name": "name",
    "nodes": "hasPart",
    "path": "rust:path",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "relative_path": "rust:relativePath",
    "rust": "https://w3id.org/rust/vocab#",
    "source": "rust:source",
    "stats": "rust:statistics",
    "successfully_parsed": "rust:successfullyParsed",
    "target": "rust:target",
    "target_type": "rust:targetType",
    "test_attributes": "rust:testAttributes",
    "total_files": "rust:totalFiles",
    "trait_name": "rust:traitName",
    "type_references": "rust:typeReferences",
    "variants": "rust:variants",
    "visibility": "rust:visibility",
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "@type": "rust:Crate",
  "@id": "crate:common",
  "crate_name": "common",
  "crate_path": "crates/common",
  "files": [
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/operation.rs",
      "path": "../crates/common/src/operation.rs",
      "relative_path": "crates/common/src/operation.rs",
      "file_size": 6144,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_anyhow_{bail,ensure,Result}",
            "path": "anyhow :: { bail , ensure , Result }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_std_{self,fmt_Display}",
            "path": "std :: { self , fmt :: Display }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_prism_keys_{Signature,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { Signature , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_prism_serde_raw_or_b64",
            "path": "prism_serde :: raw_or_b64",
            "visibility": "private"
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/operation.rs#Operation",
            "name": "Operation",
            "visibility": "pub",
            "variants": [
              "CreateAccount",
              "RegisterService",
              "AddData",
              "SetData",
              "AddKey",
              "RevokeKey"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/operation.rs#SignatureBundle",
            "name": "SignatureBundle",
            "visibility": "pub",
            "fields": [
              {
                "name": "verifying_key",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              },
              {
                "name": "signature",
                "type_name": "Signature",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_SignatureBundle",
            "target_type": "SignatureBundle",
            "trait_name": null,
            "items": [
              "# [doc = \" Creates a new `SignatureBundle` with the given verifying key and signature.\"] pub fn new (verifying_key : VerifyingKey , signature : Signature) -> Self { SignatureBundle { verifying_key , signature , } }"
            ],
            "generics": []
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/operation.rs#ServiceChallengeInput",
            "name": "ServiceChallengeInput",
            "visibility": "pub",
            "variants": [
              "Signed"
            ],
            "generics": []
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/operation.rs#ServiceChallenge",
            "name": "ServiceChallenge",
            "visibility": "pub",
            "variants": [
              "Signed"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_From<SigningKey>_ServiceChallenge",
            "target_type": "ServiceChallenge",
            "trait_name": "From < SigningKey >",
            "items": [
              "fn from (sk : SigningKey) -> Self { ServiceChallenge :: Signed (sk . into ()) }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_Operation",
            "target_type": "Operation",
            "trait_name": null,
            "items": [
              "pub fn get_public_key (& self) -> Option < & VerifyingKey > { match self { Operation :: RevokeKey { key } | Operation :: AddKey { key } | Operation :: CreateAccount { key , .. } | Operation :: RegisterService { key , .. } => Some (key) , Operation :: AddData { .. } | Operation :: SetData { .. } => None , } }",
              "pub fn validate_basic (& self) -> Result < () > { match & self { Operation :: RegisterService { id , .. } => { if id . is_empty () { bail ! (\"id must not be empty when registering service\") ; } Ok (()) } Operation :: CreateAccount { id , service_id , .. } => { if id . is_empty () { bail ! (\"id must not be empty when creating account service\") ; } if service_id . is_empty () { bail ! (\"service_id must not be empty when creating account service\") ; } Ok (()) } Operation :: AddKey { .. } | Operation :: RevokeKey { .. } => Ok (()) , Operation :: AddData { data , .. } | Operation :: SetData { data , .. } => { let data_len = data . len () ; ensure ! (data_len < usize :: MAX , \"Incoming data size is {}\" , data_len) ; Ok (()) } } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_Display_Operation",
            "target_type": "Operation",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , \"{:?}\" , self) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_anyhow_{bail,ensure,Result}",
            "path": "anyhow :: { bail , ensure , Result }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_std_{self,fmt_Display}",
            "path": "std :: { self , fmt :: Display }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_prism_keys_{Signature,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { Signature , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/operation.rs#use_prism_serde_raw_or_b64",
            "path": "prism_serde :: raw_or_b64",
            "visibility": "private"
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/operation.rs#Operation",
            "name": "Operation",
            "visibility": "pub",
            "variants": [
              "CreateAccount",
              "RegisterService",
              "AddData",
              "SetData",
              "AddKey",
              "RevokeKey"
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/operation.rs#SignatureBundle",
            "name": "SignatureBundle",
            "visibility": "pub",
            "fields": [
              {
                "name": "verifying_key",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              },
              {
                "name": "signature",
                "type_name": "Signature",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_SignatureBundle",
            "target_type": "SignatureBundle",
            "trait_name": null,
            "items": [
              "# [doc = \" Creates a new `SignatureBundle` with the given verifying key and signature.\"] pub fn new (verifying_key : VerifyingKey , signature : Signature) -> Self { SignatureBundle { verifying_key , signature , } }"
            ],
            "generics": []
          },
          "type_references": [
            "SignatureBundle"
          ]
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/operation.rs#ServiceChallengeInput",
            "name": "ServiceChallengeInput",
            "visibility": "pub",
            "variants": [
              "Signed"
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/operation.rs#ServiceChallenge",
            "name": "ServiceChallenge",
            "visibility": "pub",
            "variants": [
              "Signed"
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_From<SigningKey>_ServiceChallenge",
            "target_type": "ServiceChallenge",
            "trait_name": "From < SigningKey >",
            "items": [
              "fn from (sk : SigningKey) -> Self { ServiceChallenge :: Signed (sk . into ()) }"
            ],
            "generics": []
          },
          "type_references": [
            "ServiceChallenge"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_Operation",
            "target_type": "Operation",
            "trait_name": null,
            "items": [
              "pub fn get_public_key (& self) -> Option < & VerifyingKey > { match self { Operation :: RevokeKey { key } | Operation :: AddKey { key } | Operation :: CreateAccount { key , .. } | Operation :: RegisterService { key , .. } => Some (key) , Operation :: AddData { .. } | Operation :: SetData { .. } => None , } }",
              "pub fn validate_basic (& self) -> Result < () > { match & self { Operation :: RegisterService { id , .. } => { if id . is_empty () { bail ! (\"id must not be empty when registering service\") ; } Ok (()) } Operation :: CreateAccount { id , service_id , .. } => { if id . is_empty () { bail ! (\"id must not be empty when creating account service\") ; } if service_id . is_empty () { bail ! (\"service_id must not be empty when creating account service\") ; } Ok (()) } Operation :: AddKey { .. } | Operation :: RevokeKey { .. } => Ok (()) , Operation :: AddData { data , .. } | Operation :: SetData { data , .. } => { let data_len = data . len () ; ensure ! (data_len < usize :: MAX , \"Incoming data size is {}\" , data_len) ; Ok (()) } } }"
            ],
            "generics": []
          },
          "type_references": [
            "Operation"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/operation.rs#impl_Display_Operation",
            "target_type": "Operation",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , \"{:?}\" , self) }"
            ],
            "generics": []
          },
          "type_references": [
            "Operation"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/transaction.rs",
      "path": "../crates/common/src/transaction.rs",
      "relative_path": "crates/common/src/transaction.rs",
      "file_size": 4365,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_std_{error_Error,fmt_{Display,Formatter},}",
            "path": "std :: { error :: Error , fmt :: { Display , Formatter } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_anyhow_Result",
            "path": "anyhow :: Result",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_celestia_types_Blob",
            "path": "celestia_types :: Blob",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_prism_keys_{Signature,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { Signature , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_prism_serde_binary_{FromBinary,ToBinary}",
            "path": "prism_serde :: binary :: { FromBinary , ToBinary }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_crate_operation_{Operation,SignatureBundle}",
            "path": "crate :: operation :: { Operation , SignatureBundle }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/transaction.rs#UnsignedTransaction",
            "name": "UnsignedTransaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "pub"
              },
              {
                "name": "operation",
                "type_name": "Operation",
                "visibility": "pub"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_UnsignedTransaction",
            "target_type": "UnsignedTransaction",
            "trait_name": null,
            "items": [
              "# [doc = \" Signs the transaction with the given [`SigningKey`] and gives out a full [`Transaction`].\"] pub fn sign (self , sk : & SigningKey) -> Result < Transaction , TransactionError > { let bytes = self . signing_payload () ? ; let signature = sk . sign (& bytes) . map_err (| _ | TransactionError :: SigningFailed) ? ; Ok (Transaction { id : self . id , operation : self . operation , nonce : self . nonce , signature , vk : sk . verifying_key () , }) }",
              "# [doc = \" Creates a full transaction by adding an externally provided signature.\"] # [doc = \" Can be used to create a transaction that has been signed by an external source,\"] # [doc = \" such as a wallet or a mobile app.\"] pub fn externally_signed (self , signature_bundle : SignatureBundle) -> Transaction { Transaction { id : self . id , operation : self . operation , nonce : self . nonce , signature : signature_bundle . signature , vk : signature_bundle . verifying_key , } }",
              "# [doc = \" Returns the transaction's payload that needs to be signed, or a TransactionError if encoding fails.\"] pub fn signing_payload (& self) -> Result < Vec < u8 > , TransactionError > { self . encode_to_bytes () . map_err (| _ | TransactionError :: EncodingFailed) }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/transaction.rs#Transaction",
            "name": "Transaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "pub"
              },
              {
                "name": "operation",
                "type_name": "Operation",
                "visibility": "pub"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "pub"
              },
              {
                "name": "signature",
                "type_name": "Signature",
                "visibility": "pub"
              },
              {
                "name": "vk",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_Transaction",
            "target_type": "Transaction",
            "trait_name": null,
            "items": [
              "# [doc = \" Verifies the signature of the transaction\"] pub fn verify_signature (& self) -> Result < () > { let message = self . to_unsigned_tx () . encode_to_bytes () ? ; self . vk . verify_signature (& message , & self . signature) }",
              "# [doc = \" Extracts the part of the transaction that was signed\"] fn to_unsigned_tx (& self) -> UnsignedTransaction { UnsignedTransaction { id : self . id . clone () , operation : self . operation . clone () , nonce : self . nonce , } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_TryFrom<&Blob>_Transaction",
            "target_type": "Transaction",
            "trait_name": "TryFrom < & Blob >",
            "items": [
              "type Error = anyhow :: Error ;",
              "fn try_from (value : & Blob) -> Result < Self , Self :: Error > { Transaction :: decode_from_bytes (& value . data) . map_err (| e | e . into ()) }"
            ],
            "generics": []
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/transaction.rs#TransactionError",
            "name": "TransactionError",
            "visibility": "pub",
            "variants": [
              "InvalidOp",
              "InvalidNonce",
              "MissingKey",
              "EncodingFailed",
              "SigningFailed",
              "MissingSender"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_Display_TransactionError",
            "target_type": "TransactionError",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut Formatter < '_ >) -> std :: fmt :: Result { match self { TransactionError :: InvalidOp (msg) => write ! (f , \"Invalid operation: {}\" , msg) , TransactionError :: InvalidNonce (nonce) => write ! (f , \"Invalid nonce: {}\" , nonce) , TransactionError :: MissingKey => write ! (f , \"Public Key for account is missing\") , TransactionError :: EncodingFailed => write ! (f , \"Encoding transaction failed\") , TransactionError :: SigningFailed => write ! (f , \"Signing transaction failed\") , TransactionError :: MissingSender => write ! (f , \"Sender for transaction is missing\") , } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_Error_TransactionError",
            "target_type": "TransactionError",
            "trait_name": "Error",
            "items": [],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_std_{error_Error,fmt_{Display,Formatter},}",
            "path": "std :: { error :: Error , fmt :: { Display , Formatter } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_anyhow_Result",
            "path": "anyhow :: Result",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_celestia_types_Blob",
            "path": "celestia_types :: Blob",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_prism_keys_{Signature,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { Signature , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_prism_serde_binary_{FromBinary,ToBinary}",
            "path": "prism_serde :: binary :: { FromBinary , ToBinary }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/transaction.rs#use_crate_operation_{Operation,SignatureBundle}",
            "path": "crate :: operation :: { Operation , SignatureBundle }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/transaction.rs#UnsignedTransaction",
            "name": "UnsignedTransaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "pub"
              },
              {
                "name": "operation",
                "type_name": "Operation",
                "visibility": "pub"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_UnsignedTransaction",
            "target_type": "UnsignedTransaction",
            "trait_name": null,
            "items": [
              "# [doc = \" Signs the transaction with the given [`SigningKey`] and gives out a full [`Transaction`].\"] pub fn sign (self , sk : & SigningKey) -> Result < Transaction , TransactionError > { let bytes = self . signing_payload () ? ; let signature = sk . sign (& bytes) . map_err (| _ | TransactionError :: SigningFailed) ? ; Ok (Transaction { id : self . id , operation : self . operation , nonce : self . nonce , signature , vk : sk . verifying_key () , }) }",
              "# [doc = \" Creates a full transaction by adding an externally provided signature.\"] # [doc = \" Can be used to create a transaction that has been signed by an external source,\"] # [doc = \" such as a wallet or a mobile app.\"] pub fn externally_signed (self , signature_bundle : SignatureBundle) -> Transaction { Transaction { id : self . id , operation : self . operation , nonce : self . nonce , signature : signature_bundle . signature , vk : signature_bundle . verifying_key , } }",
              "# [doc = \" Returns the transaction's payload that needs to be signed, or a TransactionError if encoding fails.\"] pub fn signing_payload (& self) -> Result < Vec < u8 > , TransactionError > { self . encode_to_bytes () . map_err (| _ | TransactionError :: EncodingFailed) }"
            ],
            "generics": []
          },
          "type_references": [
            "UnsignedTransaction"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/transaction.rs#Transaction",
            "name": "Transaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "pub"
              },
              {
                "name": "operation",
                "type_name": "Operation",
                "visibility": "pub"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "pub"
              },
              {
                "name": "signature",
                "type_name": "Signature",
                "visibility": "pub"
              },
              {
                "name": "vk",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_Transaction",
            "target_type": "Transaction",
            "trait_name": null,
            "items": [
              "# [doc = \" Verifies the signature of the transaction\"] pub fn verify_signature (& self) -> Result < () > { let message = self . to_unsigned_tx () . encode_to_bytes () ? ; self . vk . verify_signature (& message , & self . signature) }",
              "# [doc = \" Extracts the part of the transaction that was signed\"] fn to_unsigned_tx (& self) -> UnsignedTransaction { UnsignedTransaction { id : self . id . clone () , operation : self . operation . clone () , nonce : self . nonce , } }"
            ],
            "generics": []
          },
          "type_references": [
            "Transaction"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_TryFrom<&Blob>_Transaction",
            "target_type": "Transaction",
            "trait_name": "TryFrom < & Blob >",
            "items": [
              "type Error = anyhow :: Error ;",
              "fn try_from (value : & Blob) -> Result < Self , Self :: Error > { Transaction :: decode_from_bytes (& value . data) . map_err (| e | e . into ()) }"
            ],
            "generics": []
          },
          "type_references": [
            "Transaction"
          ]
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/transaction.rs#TransactionError",
            "name": "TransactionError",
            "visibility": "pub",
            "variants": [
              "InvalidOp",
              "InvalidNonce",
              "MissingKey",
              "EncodingFailed",
              "SigningFailed",
              "MissingSender"
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Debug"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_Display_TransactionError",
            "target_type": "TransactionError",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut Formatter < '_ >) -> std :: fmt :: Result { match self { TransactionError :: InvalidOp (msg) => write ! (f , \"Invalid operation: {}\" , msg) , TransactionError :: InvalidNonce (nonce) => write ! (f , \"Invalid nonce: {}\" , nonce) , TransactionError :: MissingKey => write ! (f , \"Public Key for account is missing\") , TransactionError :: EncodingFailed => write ! (f , \"Encoding transaction failed\") , TransactionError :: SigningFailed => write ! (f , \"Signing transaction failed\") , TransactionError :: MissingSender => write ! (f , \"Sender for transaction is missing\") , } }"
            ],
            "generics": []
          },
          "type_references": [
            "TransactionError"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/transaction.rs#impl_Error_TransactionError",
            "target_type": "TransactionError",
            "trait_name": "Error",
            "items": [],
            "generics": []
          },
          "type_references": [
            "TransactionError"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/lib.rs",
      "path": "../crates/common/src/lib.rs",
      "relative_path": "crates/common/src/lib.rs",
      "file_size": 194,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#account",
            "name": "account",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#api",
            "name": "api",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#builder",
            "name": "builder",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#digest",
            "name": "digest",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#operation",
            "name": "operation",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#transaction",
            "name": "transaction",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#test_transaction_builder",
            "name": "test_transaction_builder",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#tests",
            "name": "tests",
            "visibility": "private",
            "items": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#account",
            "name": "account",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#api",
            "name": "api",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#builder",
            "name": "builder",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#digest",
            "name": "digest",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#operation",
            "name": "operation",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#transaction",
            "name": "transaction",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#test_transaction_builder",
            "name": "test_transaction_builder",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/lib.rs#tests",
            "name": "tests",
            "visibility": "private",
            "items": []
          }
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/tests/mod.rs",
      "path": "../crates/common/src/tests/mod.rs",
      "relative_path": "crates/common/src/tests/mod.rs",
      "file_size": 4762,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/tests/mod.rs#use_prism_keys_SigningKey",
            "path": "prism_keys :: SigningKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/tests/mod.rs#use_crate_{account_Account,operation_Operation}",
            "path": "crate :: { account :: Account , operation :: Operation }",
            "visibility": "private"
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
            "name": "test_process_register_service_transactions",
            "visibility": "private",
            "is_async": false,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
            "name": "test_process_create_account_transactions",
            "visibility": "private",
            "is_async": false,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/tests/mod.rs#use_prism_keys_SigningKey",
            "path": "prism_keys :: SigningKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/tests/mod.rs#use_crate_{account_Account,operation_Operation}",
            "path": "crate :: { account :: Account , operation :: Operation }",
            "visibility": "private"
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
            "name": "test_process_register_service_transactions",
            "visibility": "private",
            "is_async": false,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "SigningKey::new_ed25519",
              "is_method": false
            },
            {
              "callee": "SigningKey::new_ed25519",
              "is_method": false
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "requiring_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "register_service",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "service_key"
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "challenge_key"
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "requiring_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "register_service",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "service_key"
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "challenge_key"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true,
              "receiver_type": "unsigned_invalid_tx"
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "requiring_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "register_service",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "service_key"
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "challenge_key"
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true,
              "receiver_type": "unsigned_invalid_tx"
            },
            {
              "callee": "SigningKey::new_ed25519",
              "is_method": false
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "requiring_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "register_service",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "service_key"
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "challenge_key"
            }
          ],
          "local_variables": [
            {
              "name": "service_key",
              "is_mutable": false
            },
            {
              "name": "challenge_key",
              "is_mutable": false
            },
            {
              "name": "create_tx",
              "is_mutable": false
            },
            {
              "name": "unsigned_invalid_tx",
              "is_mutable": true
            },
            {
              "name": "invalid_tx",
              "is_mutable": false
            },
            {
              "name": "unsigned_invalid_tx",
              "is_mutable": true
            },
            {
              "name": "invalid_tx",
              "is_mutable": false
            },
            {
              "name": "invalid_key",
              "is_mutable": false
            },
            {
              "name": "invalid_tx",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "panic",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            }
          ],
          "test_attributes": {
            "is_test": true,
            "is_benchmark": false,
            "test_name": null,
            "should_panic": false,
            "ignore": false
          }
        },
        {
          "Function": {
            "@type": "rust:Function",
            "@id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
            "name": "test_process_create_account_transactions",
            "visibility": "private",
            "is_async": false,
            "is_unsafe": false,
            "inputs": [],
            "output": null,
            "generics": []
          },
          "function_calls": [
            {
              "callee": "SigningKey::new_ed25519",
              "is_method": false
            },
            {
              "callee": "SigningKey::new_ed25519",
              "is_method": false
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "meeting_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "for_service_with_id",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "create_account",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "acc_key"
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "meeting_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "for_service_with_id",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "create_account",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "acc_key"
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true,
              "receiver_type": "unsigned_invalid_tx"
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "meeting_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "for_service_with_id",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "create_account",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "acc_key"
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true,
              "receiver_type": "unsigned_invalid_tx"
            },
            {
              "callee": "SigningKey::new_ed25519",
              "is_method": false
            },
            {
              "callee": "transaction",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "sign",
              "is_method": true
            },
            {
              "callee": "unwrap",
              "is_method": true
            },
            {
              "callee": "meeting_signed_challenge",
              "is_method": true
            },
            {
              "callee": "with_key",
              "is_method": true
            },
            {
              "callee": "for_service_with_id",
              "is_method": true
            },
            {
              "callee": "with_id",
              "is_method": true
            },
            {
              "callee": "create_account",
              "is_method": true
            },
            {
              "callee": "Account::builder",
              "is_method": false
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "to_string",
              "is_method": true
            },
            {
              "callee": "verifying_key",
              "is_method": true,
              "receiver_type": "acc_key"
            }
          ],
          "local_variables": [
            {
              "name": "service_key",
              "is_mutable": false
            },
            {
              "name": "acc_key",
              "is_mutable": false
            },
            {
              "name": "create_tx",
              "is_mutable": false
            },
            {
              "name": "unsigned_invalid_tx",
              "is_mutable": true
            },
            {
              "name": "invalid_tx",
              "is_mutable": false
            },
            {
              "name": "unsigned_invalid_tx",
              "is_mutable": true
            },
            {
              "name": "invalid_tx",
              "is_mutable": false
            },
            {
              "name": "invalid_key",
              "is_mutable": false
            },
            {
              "name": "invalid_tx",
              "is_mutable": false
            }
          ],
          "type_references": [],
          "macro_invocations": [
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "panic",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            },
            {
              "name": "assert",
              "kind": "function-like"
            }
          ],
          "test_attributes": {
            "is_test": true,
            "is_benchmark": false,
            "test_name": null,
            "should_panic": false,
            "ignore": false
          }
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/digest.rs",
      "path": "../crates/common/src/digest.rs",
      "relative_path": "crates/common/src/digest.rs",
      "file_size": 2375,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_std_fmt_Display",
            "path": "std :: fmt :: Display",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_anyhow_Result",
            "path": "anyhow :: Result",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_prism_serde_{base64_FromBase64,hex_{FromHex,ToHex},raw_or_hex,}",
            "path": "prism_serde :: { base64 :: FromBase64 , hex :: { FromHex , ToHex } , raw_or_hex , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_sha2_{Digestas_,Sha256}",
            "path": "sha2 :: { Digest as _ , Sha256 }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/digest.rs#Digest",
            "name": "Digest",
            "visibility": "pub",
            "fields": [
              {
                "name": "0",
                "type_name": "[u8 ; 32]",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_Digest",
            "target_type": "Digest",
            "trait_name": null,
            "items": [
              "pub const fn new (bytes : [u8 ; 32]) -> Self { Digest (bytes) }",
              "pub fn hash (data : impl AsRef < [u8] >) -> Self { let mut hasher = Sha256 :: new () ; hasher . update (data . as_ref ()) ; Self (hasher . finalize () . into ()) }",
              "pub fn hash_items (items : & [impl AsRef < [u8] >]) -> Self { let mut hasher = Sha256 :: new () ; for item in items { hasher . update (item . as_ref ()) ; } Self (hasher . finalize () . into ()) }",
              "pub const fn zero () -> Self { Self ([0u8 ; 32]) }",
              "pub fn to_bytes (& self) -> [u8 ; 32] { self . 0 }",
              "pub fn as_bytes (& self) -> & [u8 ; 32] { & self . 0 }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_Default_Digest",
            "target_type": "Digest",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { Self :: zero () }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_From<[u8;N]>_Digest",
            "target_type": "Digest",
            "trait_name": "From < [u8 ; N] >",
            "items": [
              "fn from (value : [u8 ; N]) -> Self { assert ! (N <= 32 , \"Input array must not exceed 32 bytes\") ; let mut digest = [0u8 ; 32] ; digest [.. N] . copy_from_slice (& value) ; Self (digest) }"
            ],
            "generics": [
              "N"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_AsRef<[u8]>_Digest",
            "target_type": "Digest",
            "trait_name": "AsRef < [u8] >",
            "items": [
              "fn as_ref (& self) -> & [u8] { & self . 0 }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_FromHex_Digest",
            "target_type": "Digest",
            "trait_name": "FromHex",
            "items": [
              "type Error = anyhow :: Error ;",
              "fn from_hex < T : AsRef < [u8] > > (hex : T) -> std :: result :: Result < Self , Self :: Error > { Ok (Self (< [u8 ; 32] > :: from_hex (hex) ?)) }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_FromBase64_Digest",
            "target_type": "Digest",
            "trait_name": "FromBase64",
            "items": [
              "type Error = anyhow :: Error ;",
              "fn from_base64 < T : AsRef < [u8] > > (base64 : T) -> Result < Self , Self :: Error > { Ok (Self (< [u8 ; 32] > :: from_base64 (base64) ?)) }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_Display_Digest",
            "target_type": "Digest",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , \"{}\" , self . to_hex ()) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_std_fmt_Display",
            "path": "std :: fmt :: Display",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_anyhow_Result",
            "path": "anyhow :: Result",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_prism_serde_{base64_FromBase64,hex_{FromHex,ToHex},raw_or_hex,}",
            "path": "prism_serde :: { base64 :: FromBase64 , hex :: { FromHex , ToHex } , raw_or_hex , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_sha2_{Digestas_,Sha256}",
            "path": "sha2 :: { Digest as _ , Sha256 }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/digest.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/digest.rs#Digest",
            "name": "Digest",
            "visibility": "pub",
            "fields": [
              {
                "name": "0",
                "type_name": "[u8 ; 32]",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Debug",
            "Clone",
            "Serialize",
            "Deserialize",
            "PartialEq",
            "Eq",
            "Copy",
            "ToSchema"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_Digest",
            "target_type": "Digest",
            "trait_name": null,
            "items": [
              "pub const fn new (bytes : [u8 ; 32]) -> Self { Digest (bytes) }",
              "pub fn hash (data : impl AsRef < [u8] >) -> Self { let mut hasher = Sha256 :: new () ; hasher . update (data . as_ref ()) ; Self (hasher . finalize () . into ()) }",
              "pub fn hash_items (items : & [impl AsRef < [u8] >]) -> Self { let mut hasher = Sha256 :: new () ; for item in items { hasher . update (item . as_ref ()) ; } Self (hasher . finalize () . into ()) }",
              "pub const fn zero () -> Self { Self ([0u8 ; 32]) }",
              "pub fn to_bytes (& self) -> [u8 ; 32] { self . 0 }",
              "pub fn as_bytes (& self) -> & [u8 ; 32] { & self . 0 }"
            ],
            "generics": []
          },
          "type_references": [
            "Digest"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_Default_Digest",
            "target_type": "Digest",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { Self :: zero () }"
            ],
            "generics": []
          },
          "type_references": [
            "Digest"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_From<[u8;N]>_Digest",
            "target_type": "Digest",
            "trait_name": "From < [u8 ; N] >",
            "items": [
              "fn from (value : [u8 ; N]) -> Self { assert ! (N <= 32 , \"Input array must not exceed 32 bytes\") ; let mut digest = [0u8 ; 32] ; digest [.. N] . copy_from_slice (& value) ; Self (digest) }"
            ],
            "generics": [
              "N"
            ]
          },
          "type_references": [
            "Digest"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_AsRef<[u8]>_Digest",
            "target_type": "Digest",
            "trait_name": "AsRef < [u8] >",
            "items": [
              "fn as_ref (& self) -> & [u8] { & self . 0 }"
            ],
            "generics": []
          },
          "type_references": [
            "Digest"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_FromHex_Digest",
            "target_type": "Digest",
            "trait_name": "FromHex",
            "items": [
              "type Error = anyhow :: Error ;",
              "fn from_hex < T : AsRef < [u8] > > (hex : T) -> std :: result :: Result < Self , Self :: Error > { Ok (Self (< [u8 ; 32] > :: from_hex (hex) ?)) }"
            ],
            "generics": []
          },
          "type_references": [
            "Digest"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_FromBase64_Digest",
            "target_type": "Digest",
            "trait_name": "FromBase64",
            "items": [
              "type Error = anyhow :: Error ;",
              "fn from_base64 < T : AsRef < [u8] > > (base64 : T) -> Result < Self , Self :: Error > { Ok (Self (< [u8 ; 32] > :: from_base64 (base64) ?)) }"
            ],
            "generics": []
          },
          "type_references": [
            "Digest"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/digest.rs#impl_Display_Digest",
            "target_type": "Digest",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , \"{}\" , self . to_hex ()) }"
            ],
            "generics": []
          },
          "type_references": [
            "Digest"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/account.rs",
      "path": "../crates/common/src/account.rs",
      "relative_path": "crates/common/src/account.rs",
      "file_size": 7812,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_anyhow_{anyhow,bail,Result}",
            "path": "anyhow :: { anyhow , bail , Result }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_prism_keys_VerifyingKey",
            "path": "prism_keys :: VerifyingKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_prism_serde_raw_or_b64",
            "path": "prism_serde :: raw_or_b64",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_crate_{api_{noop_NoopPrismApi,PrismApi},builder_{ModifyAccountRequestBuilder,RequestBuilder},operation_{Operation,ServiceChallenge},transaction_Transaction,}",
            "path": "crate :: { api :: { noop :: NoopPrismApi , PrismApi } , builder :: { ModifyAccountRequestBuilder , RequestBuilder } , operation :: { Operation , ServiceChallenge } , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/account.rs#SignedData",
            "name": "SignedData",
            "visibility": "pub",
            "fields": [
              {
                "name": "key",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              },
              {
                "name": "data",
                "type_name": "Vec < u8 >",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/account.rs#Account",
            "name": "Account",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "private"
              },
              {
                "name": "valid_keys",
                "type_name": "Vec < VerifyingKey >",
                "visibility": "private"
              },
              {
                "name": "signed_data",
                "type_name": "Vec < SignedData >",
                "visibility": "private"
              },
              {
                "name": "service_challenge",
                "type_name": "Option < ServiceChallenge >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/account.rs#impl_Account",
            "target_type": "Account",
            "trait_name": null,
            "items": [
              "pub fn id (& self) -> & str { & self . id }",
              "pub fn nonce (& self) -> u64 { self . nonce }",
              "pub fn valid_keys (& self) -> & [VerifyingKey] { & self . valid_keys }",
              "pub fn signed_data (& self) -> & [SignedData] { & self . signed_data }",
              "pub fn service_challenge (& self) -> Option < & ServiceChallenge > { self . service_challenge . as_ref () }",
              "# [doc = \" Creates a new request builder with the default NoopPrismApi implementation.\"] # [doc = \" This is useful for local testing and validation without a real API connection.\"] pub fn builder < 'a > () -> RequestBuilder < 'a , NoopPrismApi > { RequestBuilder :: new () }",
              "# [doc = \" Creates a new request builder using the provided PrismApi implementation.\"] # [doc = \" This allows interaction with a specific API instance.\"] pub fn builder_via_api < P > (prism : & P) -> RequestBuilder < '_ , P > where P : PrismApi , { RequestBuilder :: new_with_prism (prism) }",
              "# [doc = \" Creates a modification request builder for this account using the default NoopPrismApi.\"] # [doc = \" This is useful for local testing and validation without a real API connection.\"] pub fn modify (& self) -> ModifyAccountRequestBuilder < NoopPrismApi > { RequestBuilder :: new () . to_modify_account (self) }",
              "# [doc = \" Creates a modification request builder for this account using the provided PrismApi implementation.\"] # [doc = \" This allows building and submitting transactions that modify the current account state through a specific API.\"] pub fn modify_via_api < 'a , P > (& self , prism : & 'a P) -> ModifyAccountRequestBuilder < 'a , P > where P : PrismApi , { RequestBuilder :: new_with_prism (prism) . to_modify_account (self) }",
              "# [doc = \" Validates and processes an incoming [`Transaction`], updating the account state.\"] pub fn process_transaction (& mut self , tx : & Transaction) -> Result < () > { self . validate_transaction (tx) ? ; self . process_operation (& tx . operation) ? ; self . nonce += 1 ; Ok (()) }",
              "# [doc = \" Validates a transaction against the current account state. Please note\"] # [doc = \" that the operation must be validated separately.\"] fn validate_transaction (& self , tx : & Transaction) -> Result < () > { if tx . nonce != self . nonce { return Err (anyhow ! (\"Nonce does not match. {} != {}\" , tx . nonce , self . nonce)) ; } match & tx . operation { Operation :: CreateAccount { id , key , .. } | Operation :: RegisterService { id , key , .. } => { if & tx . id != id { bail ! (\"Transaction ID does not match operation ID\") ; } if & tx . vk != key { bail ! (\"Transaction key does not match operation key\") ; } } _ => { if tx . id != self . id { bail ! (\"Transaction ID does not match account ID\") ; } if ! self . valid_keys . contains (& tx . vk) { bail ! (\"Invalid key\") ; } } } tx . verify_signature () ? ; Ok (()) }",
              "# [doc = \" Validates an operation against the current account state.\"] fn validate_operation (& self , operation : & Operation) -> Result < () > { match operation { Operation :: AddKey { key } => { if self . valid_keys . contains (key) { return Err (anyhow ! (\"Key already exists\")) ; } } Operation :: RevokeKey { key } => { if ! self . valid_keys . contains (key) { return Err (anyhow ! (\"Key does not exist\")) ; } } Operation :: AddData { data , data_signature , } | Operation :: SetData { data , data_signature , } => { if ! self . valid_keys () . contains (& data_signature . verifying_key) { data_signature . verifying_key . verify_signature (data , & data_signature . signature) ? ; } } Operation :: CreateAccount { .. } | Operation :: RegisterService { .. } => { if ! self . is_empty () { return Err (anyhow ! (\"Account already exists\")) ; } } } Ok (()) }",
              "# [doc = \" Processes an operation, updating the account state. Should only be run\"] # [doc = \" in the context of a transaction.\"] fn process_operation (& mut self , operation : & Operation) -> Result < () > { self . validate_operation (operation) ? ; match operation { Operation :: AddKey { key } => { self . valid_keys . push (key . clone ()) ; } Operation :: RevokeKey { key } => { self . valid_keys . retain (| k | k != key) ; } Operation :: AddData { data , data_signature , } => { self . signed_data . push (SignedData { key : data_signature . verifying_key . clone () , data : data . clone () , }) ; } Operation :: SetData { data , data_signature , } => { self . signed_data = vec ! [SignedData { key : data_signature . verifying_key . clone () , data : data . clone () , }] ; } Operation :: CreateAccount { id , key , .. } => { self . id = id . clone () ; self . valid_keys . push (key . clone ()) ; } Operation :: RegisterService { id , creation_gate , key , } => { self . id = id . clone () ; self . valid_keys . push (key . clone ()) ; self . service_challenge = Some (creation_gate . clone ()) ; } } Ok (()) }",
              "pub fn is_empty (& self) -> bool { self . nonce == 0 }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_anyhow_{anyhow,bail,Result}",
            "path": "anyhow :: { anyhow , bail , Result }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_prism_keys_VerifyingKey",
            "path": "prism_keys :: VerifyingKey",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_prism_serde_raw_or_b64",
            "path": "prism_serde :: raw_or_b64",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/account.rs#use_crate_{api_{noop_NoopPrismApi,PrismApi},builder_{ModifyAccountRequestBuilder,RequestBuilder},operation_{Operation,ServiceChallenge},transaction_Transaction,}",
            "path": "crate :: { api :: { noop :: NoopPrismApi , PrismApi } , builder :: { ModifyAccountRequestBuilder , RequestBuilder } , operation :: { Operation , ServiceChallenge } , transaction :: Transaction , }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/account.rs#SignedData",
            "name": "SignedData",
            "visibility": "pub",
            "fields": [
              {
                "name": "key",
                "type_name": "VerifyingKey",
                "visibility": "pub"
              },
              {
                "name": "data",
                "type_name": "Vec < u8 >",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/account.rs#Account",
            "name": "Account",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "private"
              },
              {
                "name": "valid_keys",
                "type_name": "Vec < VerifyingKey >",
                "visibility": "private"
              },
              {
                "name": "signed_data",
                "type_name": "Vec < SignedData >",
                "visibility": "private"
              },
              {
                "name": "service_challenge",
                "type_name": "Option < ServiceChallenge >",
                "visibility": "private"
              }
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Serialize",
            "Deserialize",
            "Debug",
            "PartialEq",
            "Default",
            "ToSchema"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/account.rs#impl_Account",
            "target_type": "Account",
            "trait_name": null,
            "items": [
              "pub fn id (& self) -> & str { & self . id }",
              "pub fn nonce (& self) -> u64 { self . nonce }",
              "pub fn valid_keys (& self) -> & [VerifyingKey] { & self . valid_keys }",
              "pub fn signed_data (& self) -> & [SignedData] { & self . signed_data }",
              "pub fn service_challenge (& self) -> Option < & ServiceChallenge > { self . service_challenge . as_ref () }",
              "# [doc = \" Creates a new request builder with the default NoopPrismApi implementation.\"] # [doc = \" This is useful for local testing and validation without a real API connection.\"] pub fn builder < 'a > () -> RequestBuilder < 'a , NoopPrismApi > { RequestBuilder :: new () }",
              "# [doc = \" Creates a new request builder using the provided PrismApi implementation.\"] # [doc = \" This allows interaction with a specific API instance.\"] pub fn builder_via_api < P > (prism : & P) -> RequestBuilder < '_ , P > where P : PrismApi , { RequestBuilder :: new_with_prism (prism) }",
              "# [doc = \" Creates a modification request builder for this account using the default NoopPrismApi.\"] # [doc = \" This is useful for local testing and validation without a real API connection.\"] pub fn modify (& self) -> ModifyAccountRequestBuilder < NoopPrismApi > { RequestBuilder :: new () . to_modify_account (self) }",
              "# [doc = \" Creates a modification request builder for this account using the provided PrismApi implementation.\"] # [doc = \" This allows building and submitting transactions that modify the current account state through a specific API.\"] pub fn modify_via_api < 'a , P > (& self , prism : & 'a P) -> ModifyAccountRequestBuilder < 'a , P > where P : PrismApi , { RequestBuilder :: new_with_prism (prism) . to_modify_account (self) }",
              "# [doc = \" Validates and processes an incoming [`Transaction`], updating the account state.\"] pub fn process_transaction (& mut self , tx : & Transaction) -> Result < () > { self . validate_transaction (tx) ? ; self . process_operation (& tx . operation) ? ; self . nonce += 1 ; Ok (()) }",
              "# [doc = \" Validates a transaction against the current account state. Please note\"] # [doc = \" that the operation must be validated separately.\"] fn validate_transaction (& self , tx : & Transaction) -> Result < () > { if tx . nonce != self . nonce { return Err (anyhow ! (\"Nonce does not match. {} != {}\" , tx . nonce , self . nonce)) ; } match & tx . operation { Operation :: CreateAccount { id , key , .. } | Operation :: RegisterService { id , key , .. } => { if & tx . id != id { bail ! (\"Transaction ID does not match operation ID\") ; } if & tx . vk != key { bail ! (\"Transaction key does not match operation key\") ; } } _ => { if tx . id != self . id { bail ! (\"Transaction ID does not match account ID\") ; } if ! self . valid_keys . contains (& tx . vk) { bail ! (\"Invalid key\") ; } } } tx . verify_signature () ? ; Ok (()) }",
              "# [doc = \" Validates an operation against the current account state.\"] fn validate_operation (& self , operation : & Operation) -> Result < () > { match operation { Operation :: AddKey { key } => { if self . valid_keys . contains (key) { return Err (anyhow ! (\"Key already exists\")) ; } } Operation :: RevokeKey { key } => { if ! self . valid_keys . contains (key) { return Err (anyhow ! (\"Key does not exist\")) ; } } Operation :: AddData { data , data_signature , } | Operation :: SetData { data , data_signature , } => { if ! self . valid_keys () . contains (& data_signature . verifying_key) { data_signature . verifying_key . verify_signature (data , & data_signature . signature) ? ; } } Operation :: CreateAccount { .. } | Operation :: RegisterService { .. } => { if ! self . is_empty () { return Err (anyhow ! (\"Account already exists\")) ; } } } Ok (()) }",
              "# [doc = \" Processes an operation, updating the account state. Should only be run\"] # [doc = \" in the context of a transaction.\"] fn process_operation (& mut self , operation : & Operation) -> Result < () > { self . validate_operation (operation) ? ; match operation { Operation :: AddKey { key } => { self . valid_keys . push (key . clone ()) ; } Operation :: RevokeKey { key } => { self . valid_keys . retain (| k | k != key) ; } Operation :: AddData { data , data_signature , } => { self . signed_data . push (SignedData { key : data_signature . verifying_key . clone () , data : data . clone () , }) ; } Operation :: SetData { data , data_signature , } => { self . signed_data = vec ! [SignedData { key : data_signature . verifying_key . clone () , data : data . clone () , }] ; } Operation :: CreateAccount { id , key , .. } => { self . id = id . clone () ; self . valid_keys . push (key . clone ()) ; } Operation :: RegisterService { id , creation_gate , key , } => { self . id = id . clone () ; self . valid_keys . push (key . clone ()) ; self . service_challenge = Some (creation_gate . clone ()) ; } } Ok (()) }",
              "pub fn is_empty (& self) -> bool { self . nonce == 0 }"
            ],
            "generics": []
          },
          "type_references": [
            "Account"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/test_transaction_builder.rs",
      "path": "../crates/common/src/test_transaction_builder.rs",
      "relative_path": "crates/common/src/test_transaction_builder.rs",
      "file_size": 18373,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/test_transaction_builder.rs#use_std_collections_HashMap",
            "path": "std :: collections :: HashMap",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/test_transaction_builder.rs#use_crate_{account_Account,digest_Digest,operation_{Operation,ServiceChallenge,ServiceChallengeInput,SignatureBundle},transaction_{Transaction,UnsignedTransaction},}",
            "path": "crate :: { account :: Account , digest :: Digest , operation :: { Operation , ServiceChallenge , ServiceChallengeInput , SignatureBundle } , transaction :: { Transaction , UnsignedTransaction } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/test_transaction_builder.rs#use_prism_keys_{CryptoAlgorithm,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/test_transaction_builder.rs#PostCommitAction",
            "name": "PostCommitAction",
            "visibility": "private",
            "variants": [
              "UpdateStorageOnly",
              "RememberServiceKey",
              "RememberAccountKey",
              "RemoveAccountKey"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/test_transaction_builder.rs#UncommittedTransaction",
            "name": "UncommittedTransaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "transaction",
                "type_name": "Transaction",
                "visibility": "private"
              },
              {
                "name": "builder",
                "type_name": "& 'a mut TestTransactionBuilder",
                "visibility": "private"
              },
              {
                "name": "post_commit_action",
                "type_name": "PostCommitAction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/test_transaction_builder.rs#impl_UncommittedTransaction<'_>",
            "target_type": "UncommittedTransaction < '_ >",
            "trait_name": null,
            "items": [
              "# [doc = \" Commits and returns a transaction, updating the builder. Subsequent transactions\"] # [doc = \" built with the same builder will have the correct previous hash.\"] pub fn commit (self) -> Transaction { let acc = self . builder . accounts . entry (self . transaction . id . clone ()) . or_default () ; acc . process_transaction (& self . transaction) . expect (\"Adding transaction entry to account should work\") ; match self . post_commit_action { PostCommitAction :: UpdateStorageOnly => () , PostCommitAction :: RememberAccountKey (id , account_key) => { self . builder . account_keys . entry (id) . or_default () . push (account_key) ; } PostCommitAction :: RemoveAccountKey (id , key) => { if let Some (keys) = self . builder . account_keys . get_mut (& id) { keys . retain (| k | k . verifying_key () != key) ; if keys . is_empty () { self . builder . account_keys . remove (& id) ; } } } PostCommitAction :: RememberServiceKey (id , service_key) => { self . builder . service_keys . insert (id , service_key) ; } } self . transaction }",
              "# [doc = \" Returns a transaction without updating the builder.\"] # [doc = \" Can be used to create invalid transactions.\"] pub fn build (self) -> Transaction { self . transaction }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/test_transaction_builder.rs#TestTransactionBuilder",
            "name": "TestTransactionBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "accounts",
                "type_name": "HashMap < String , Account >",
                "visibility": "private"
              },
              {
                "name": "service_keys",
                "type_name": "HashMap < String , SigningKey >",
                "visibility": "private"
              },
              {
                "name": "account_keys",
                "type_name": "HashMap < String , Vec < SigningKey > >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/test_transaction_builder.rs#impl_Default_TestTransactionBuilder",
            "target_type": "TestTransactionBuilder",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { let accounts = HashMap :: new () ; let service_keys = HashMap :: new () ; let account_keys = HashMap :: new () ; Self { accounts , service_keys , account_keys , } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/test_transaction_builder.rs#impl_TestTransactionBuilder",
            "target_type": "TestTransactionBuilder",
            "trait_name": null,
            "items": [
              "pub fn new () -> Self { Self :: default () }",
              "pub fn get_accounts (& self) -> & HashMap < String , Account > { & self . accounts }",
              "pub fn get_service_keys (& self) -> & HashMap < String , SigningKey > { & self . service_keys }",
              "pub fn get_account_keys (& self) -> & HashMap < String , Vec < SigningKey > > { & self . account_keys }",
              "pub fn get_account (& self , id : & str) -> Option < & Account > { self . accounts . get (id) }",
              "pub fn register_service_with_random_keys (& mut self , algorithm : CryptoAlgorithm , id : & str ,) -> UncommittedTransaction { let random_service_challenge_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create challenge key\") ; let random_service_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create signing key\") ; self . register_service (id , random_service_challenge_key , random_service_signing_key) }",
              "pub fn register_service (& mut self , id : & str , challenge_key : SigningKey , signing_key : SigningKey ,) -> UncommittedTransaction { let vk : VerifyingKey = signing_key . clone () . into () ; let op = Operation :: RegisterService { id : id . to_string () , creation_gate : ServiceChallenge :: Signed (challenge_key . verifying_key ()) , key : vk . clone () , } ; let unsigned_tx = UnsignedTransaction { id : id . to_string () , operation : op , nonce : 0 , } ; let transaction = unsigned_tx . sign (& signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: RememberServiceKey (id . to_string () , challenge_key) , } }",
              "pub fn create_account_with_random_key_signed (& mut self , algorithm : CryptoAlgorithm , id : & str , service_id : & str ,) -> UncommittedTransaction { let account_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create account signing key\") ; self . create_account_signed (id , service_id , account_signing_key) }",
              "pub fn create_account_signed (& mut self , id : & str , service_id : & str , signing_key : SigningKey ,) -> UncommittedTransaction { let Some (service_signing_key) = self . service_keys . get (service_id) . cloned () else { panic ! (\"No existing service found for {}\" , service_id) } ; self . create_account (id , service_id , & service_signing_key , signing_key) }",
              "pub fn create_account_with_random_key (& mut self , algorithm : CryptoAlgorithm , id : & str , service_id : & str , service_signing_key : & SigningKey ,) -> UncommittedTransaction { let account_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create account signing key\") ; self . create_account (id , service_id , service_signing_key , account_signing_key) }",
              "pub fn create_account (& mut self , id : & str , service_id : & str , service_signing_key : & SigningKey , signing_key : SigningKey ,) -> UncommittedTransaction { let vk = signing_key . verifying_key () ; let hash = Digest :: hash_items (& [id . as_bytes () , service_id . as_bytes () , & vk . to_bytes ()]) ; let signature = service_signing_key . sign (hash) . unwrap () ; let op = Operation :: CreateAccount { id : id . to_string () , service_id : service_id . to_string () , challenge : ServiceChallengeInput :: Signed (signature . clone ()) , key : vk . clone () , } ; let unsigned_tx = UnsignedTransaction { id : id . to_string () , operation : op , nonce : 0 , } ; let transaction = unsigned_tx . sign (& signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: RememberAccountKey (id . to_string () , signing_key) , } }",
              "pub fn add_random_key_verified_with_root (& mut self , algorithm : CryptoAlgorithm , id : & str ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . add_random_key (algorithm , id , account_signing_key) }",
              "pub fn add_random_key (& mut self , algorithm : CryptoAlgorithm , id : & str , signing_key : & SigningKey ,) -> UncommittedTransaction { let random_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create random key\") . into () ; self . add_key (id , random_key , signing_key) }",
              "pub fn add_key_verified_with_root (& mut self , id : & str , key : VerifyingKey ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . add_key (id , key , account_signing_key) }",
              "pub fn add_key (& mut self , id : & str , key : VerifyingKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: AddKey { key : key . clone () } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: UpdateStorageOnly , } }",
              "pub fn revoke_key_verified_with_root (& mut self , id : & str , key : VerifyingKey ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . revoke_key (id , key , account_signing_key) }",
              "pub fn revoke_key (& mut self , id : & str , key : VerifyingKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: RevokeKey { key : key . clone () } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: RemoveAccountKey (id . to_string () , key) , } }",
              "pub fn add_randomly_signed_data (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . add_signed_data (id , value , & value_signing_key , signing_key) }",
              "pub fn add_randomly_signed_data_verified_with_root (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . add_signed_data_verified_with_root (id , value , & value_signing_key) }",
              "pub fn add_signed_data (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . add_pre_signed_data (id , value , value_signature_bundle , signing_key) }",
              "pub fn add_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . add_pre_signed_data_verified_with_root (id , value , value_signature_bundle) }",
              "pub fn add_pre_signed_data (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle , signing_key : & SigningKey ,) -> UncommittedTransaction { self . add_data (id , value , value_signature , signing_key) }",
              "pub fn add_pre_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle ,) -> UncommittedTransaction { self . add_data_verified_with_root (id , value , value_signature) }",
              "pub fn add_internally_signed_data (& mut self , id : & str , value : Vec < u8 > , signing_key : & SigningKey ,) -> UncommittedTransaction { let bundle = SignatureBundle { verifying_key : signing_key . verifying_key () , signature : signing_key . sign (& value) . unwrap () , } ; self . add_data (id , value , bundle , signing_key) }",
              "pub fn add_internally_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; let bundle = SignatureBundle { verifying_key : account_signing_key . verifying_key () , signature : account_signing_key . sign (& value) . unwrap () , } ; self . add_data_verified_with_root (id , value , bundle) }",
              "fn add_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . add_data (id , value , value_signature , account_signing_key) }",
              "fn add_data (& mut self , id : & str , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: AddData { data , data_signature , } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: UpdateStorageOnly , } }",
              "pub fn set_randomly_signed_data (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . set_signed_data (id , value , & value_signing_key , signing_key) }",
              "pub fn set_randomly_signed_data_verified_with_root (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . set_signed_data_verified_with_root (id , value , & value_signing_key) }",
              "pub fn set_internally_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; let bundle = SignatureBundle { verifying_key : account_signing_key . verifying_key () , signature : account_signing_key . sign (& value) . unwrap () , } ; self . set_pre_signed_data (id , value , bundle , account_signing_key) }",
              "pub fn set_signed_data (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . set_pre_signed_data (id , value , value_signature_bundle , signing_key) }",
              "pub fn set_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . set_pre_signed_data_verified_with_root (id , value , value_signature_bundle) }",
              "pub fn set_pre_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . set_pre_signed_data (id , value , value_signature , account_signing_key) }",
              "pub fn set_pre_signed_data (& mut self , id : & str , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: SetData { data , data_signature , } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: UpdateStorageOnly , } }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/test_transaction_builder.rs#use_std_collections_HashMap",
            "path": "std :: collections :: HashMap",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/test_transaction_builder.rs#use_crate_{account_Account,digest_Digest,operation_{Operation,ServiceChallenge,ServiceChallengeInput,SignatureBundle},transaction_{Transaction,UnsignedTransaction},}",
            "path": "crate :: { account :: Account , digest :: Digest , operation :: { Operation , ServiceChallenge , ServiceChallengeInput , SignatureBundle } , transaction :: { Transaction , UnsignedTransaction } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/test_transaction_builder.rs#use_prism_keys_{CryptoAlgorithm,SigningKey,VerifyingKey}",
            "path": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/test_transaction_builder.rs#PostCommitAction",
            "name": "PostCommitAction",
            "visibility": "private",
            "variants": [
              "UpdateStorageOnly",
              "RememberServiceKey",
              "RememberAccountKey",
              "RemoveAccountKey"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/test_transaction_builder.rs#UncommittedTransaction",
            "name": "UncommittedTransaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "transaction",
                "type_name": "Transaction",
                "visibility": "private"
              },
              {
                "name": "builder",
                "type_name": "& 'a mut TestTransactionBuilder",
                "visibility": "private"
              },
              {
                "name": "post_commit_action",
                "type_name": "PostCommitAction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/test_transaction_builder.rs#impl_UncommittedTransaction<'_>",
            "target_type": "UncommittedTransaction < '_ >",
            "trait_name": null,
            "items": [
              "# [doc = \" Commits and returns a transaction, updating the builder. Subsequent transactions\"] # [doc = \" built with the same builder will have the correct previous hash.\"] pub fn commit (self) -> Transaction { let acc = self . builder . accounts . entry (self . transaction . id . clone ()) . or_default () ; acc . process_transaction (& self . transaction) . expect (\"Adding transaction entry to account should work\") ; match self . post_commit_action { PostCommitAction :: UpdateStorageOnly => () , PostCommitAction :: RememberAccountKey (id , account_key) => { self . builder . account_keys . entry (id) . or_default () . push (account_key) ; } PostCommitAction :: RemoveAccountKey (id , key) => { if let Some (keys) = self . builder . account_keys . get_mut (& id) { keys . retain (| k | k . verifying_key () != key) ; if keys . is_empty () { self . builder . account_keys . remove (& id) ; } } } PostCommitAction :: RememberServiceKey (id , service_key) => { self . builder . service_keys . insert (id , service_key) ; } } self . transaction }",
              "# [doc = \" Returns a transaction without updating the builder.\"] # [doc = \" Can be used to create invalid transactions.\"] pub fn build (self) -> Transaction { self . transaction }"
            ],
            "generics": []
          },
          "type_references": [
            "UncommittedTransaction"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/test_transaction_builder.rs#TestTransactionBuilder",
            "name": "TestTransactionBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "accounts",
                "type_name": "HashMap < String , Account >",
                "visibility": "private"
              },
              {
                "name": "service_keys",
                "type_name": "HashMap < String , SigningKey >",
                "visibility": "private"
              },
              {
                "name": "account_keys",
                "type_name": "HashMap < String , Vec < SigningKey > >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/test_transaction_builder.rs#impl_Default_TestTransactionBuilder",
            "target_type": "TestTransactionBuilder",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { let accounts = HashMap :: new () ; let service_keys = HashMap :: new () ; let account_keys = HashMap :: new () ; Self { accounts , service_keys , account_keys , } }"
            ],
            "generics": []
          },
          "type_references": [
            "TestTransactionBuilder"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/test_transaction_builder.rs#impl_TestTransactionBuilder",
            "target_type": "TestTransactionBuilder",
            "trait_name": null,
            "items": [
              "pub fn new () -> Self { Self :: default () }",
              "pub fn get_accounts (& self) -> & HashMap < String , Account > { & self . accounts }",
              "pub fn get_service_keys (& self) -> & HashMap < String , SigningKey > { & self . service_keys }",
              "pub fn get_account_keys (& self) -> & HashMap < String , Vec < SigningKey > > { & self . account_keys }",
              "pub fn get_account (& self , id : & str) -> Option < & Account > { self . accounts . get (id) }",
              "pub fn register_service_with_random_keys (& mut self , algorithm : CryptoAlgorithm , id : & str ,) -> UncommittedTransaction { let random_service_challenge_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create challenge key\") ; let random_service_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create signing key\") ; self . register_service (id , random_service_challenge_key , random_service_signing_key) }",
              "pub fn register_service (& mut self , id : & str , challenge_key : SigningKey , signing_key : SigningKey ,) -> UncommittedTransaction { let vk : VerifyingKey = signing_key . clone () . into () ; let op = Operation :: RegisterService { id : id . to_string () , creation_gate : ServiceChallenge :: Signed (challenge_key . verifying_key ()) , key : vk . clone () , } ; let unsigned_tx = UnsignedTransaction { id : id . to_string () , operation : op , nonce : 0 , } ; let transaction = unsigned_tx . sign (& signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: RememberServiceKey (id . to_string () , challenge_key) , } }",
              "pub fn create_account_with_random_key_signed (& mut self , algorithm : CryptoAlgorithm , id : & str , service_id : & str ,) -> UncommittedTransaction { let account_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create account signing key\") ; self . create_account_signed (id , service_id , account_signing_key) }",
              "pub fn create_account_signed (& mut self , id : & str , service_id : & str , signing_key : SigningKey ,) -> UncommittedTransaction { let Some (service_signing_key) = self . service_keys . get (service_id) . cloned () else { panic ! (\"No existing service found for {}\" , service_id) } ; self . create_account (id , service_id , & service_signing_key , signing_key) }",
              "pub fn create_account_with_random_key (& mut self , algorithm : CryptoAlgorithm , id : & str , service_id : & str , service_signing_key : & SigningKey ,) -> UncommittedTransaction { let account_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create account signing key\") ; self . create_account (id , service_id , service_signing_key , account_signing_key) }",
              "pub fn create_account (& mut self , id : & str , service_id : & str , service_signing_key : & SigningKey , signing_key : SigningKey ,) -> UncommittedTransaction { let vk = signing_key . verifying_key () ; let hash = Digest :: hash_items (& [id . as_bytes () , service_id . as_bytes () , & vk . to_bytes ()]) ; let signature = service_signing_key . sign (hash) . unwrap () ; let op = Operation :: CreateAccount { id : id . to_string () , service_id : service_id . to_string () , challenge : ServiceChallengeInput :: Signed (signature . clone ()) , key : vk . clone () , } ; let unsigned_tx = UnsignedTransaction { id : id . to_string () , operation : op , nonce : 0 , } ; let transaction = unsigned_tx . sign (& signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: RememberAccountKey (id . to_string () , signing_key) , } }",
              "pub fn add_random_key_verified_with_root (& mut self , algorithm : CryptoAlgorithm , id : & str ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . add_random_key (algorithm , id , account_signing_key) }",
              "pub fn add_random_key (& mut self , algorithm : CryptoAlgorithm , id : & str , signing_key : & SigningKey ,) -> UncommittedTransaction { let random_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create random key\") . into () ; self . add_key (id , random_key , signing_key) }",
              "pub fn add_key_verified_with_root (& mut self , id : & str , key : VerifyingKey ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . add_key (id , key , account_signing_key) }",
              "pub fn add_key (& mut self , id : & str , key : VerifyingKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: AddKey { key : key . clone () } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: UpdateStorageOnly , } }",
              "pub fn revoke_key_verified_with_root (& mut self , id : & str , key : VerifyingKey ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . revoke_key (id , key , account_signing_key) }",
              "pub fn revoke_key (& mut self , id : & str , key : VerifyingKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: RevokeKey { key : key . clone () } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: RemoveAccountKey (id . to_string () , key) , } }",
              "pub fn add_randomly_signed_data (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . add_signed_data (id , value , & value_signing_key , signing_key) }",
              "pub fn add_randomly_signed_data_verified_with_root (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . add_signed_data_verified_with_root (id , value , & value_signing_key) }",
              "pub fn add_signed_data (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . add_pre_signed_data (id , value , value_signature_bundle , signing_key) }",
              "pub fn add_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . add_pre_signed_data_verified_with_root (id , value , value_signature_bundle) }",
              "pub fn add_pre_signed_data (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle , signing_key : & SigningKey ,) -> UncommittedTransaction { self . add_data (id , value , value_signature , signing_key) }",
              "pub fn add_pre_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle ,) -> UncommittedTransaction { self . add_data_verified_with_root (id , value , value_signature) }",
              "pub fn add_internally_signed_data (& mut self , id : & str , value : Vec < u8 > , signing_key : & SigningKey ,) -> UncommittedTransaction { let bundle = SignatureBundle { verifying_key : signing_key . verifying_key () , signature : signing_key . sign (& value) . unwrap () , } ; self . add_data (id , value , bundle , signing_key) }",
              "pub fn add_internally_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; let bundle = SignatureBundle { verifying_key : account_signing_key . verifying_key () , signature : account_signing_key . sign (& value) . unwrap () , } ; self . add_data_verified_with_root (id , value , bundle) }",
              "fn add_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . add_data (id , value , value_signature , account_signing_key) }",
              "fn add_data (& mut self , id : & str , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: AddData { data , data_signature , } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: UpdateStorageOnly , } }",
              "pub fn set_randomly_signed_data (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . set_signed_data (id , value , & value_signing_key , signing_key) }",
              "pub fn set_randomly_signed_data_verified_with_root (& mut self , algorithm : CryptoAlgorithm , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let value_signing_key = SigningKey :: new_with_algorithm (algorithm) . expect (\"Failed to create value signing key\") ; self . set_signed_data_verified_with_root (id , value , & value_signing_key) }",
              "pub fn set_internally_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; let bundle = SignatureBundle { verifying_key : account_signing_key . verifying_key () , signature : account_signing_key . sign (& value) . unwrap () , } ; self . set_pre_signed_data (id , value , bundle , account_signing_key) }",
              "pub fn set_signed_data (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey , signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . set_pre_signed_data (id , value , value_signature_bundle , signing_key) }",
              "pub fn set_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signing_key : & SigningKey ,) -> UncommittedTransaction { let value_signature_bundle = SignatureBundle { verifying_key : value_signing_key . verifying_key () , signature : value_signing_key . sign (& value) . unwrap () , } ; self . set_pre_signed_data_verified_with_root (id , value , value_signature_bundle) }",
              "pub fn set_pre_signed_data_verified_with_root (& mut self , id : & str , value : Vec < u8 > , value_signature : SignatureBundle ,) -> UncommittedTransaction { let Some (account_signing_keys) = self . account_keys . get (id) . cloned () else { panic ! (\"No existing account key for {}\" , id) } ; let account_signing_key = account_signing_keys . first () . unwrap () ; self . set_pre_signed_data (id , value , value_signature , account_signing_key) }",
              "pub fn set_pre_signed_data (& mut self , id : & str , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> UncommittedTransaction { let account = self . accounts . get (id) . cloned () . unwrap_or_default () ; let op = Operation :: SetData { data , data_signature , } ; let unsigned_tx = UnsignedTransaction { id : account . id () . to_string () , operation : op , nonce : account . nonce () , } ; let transaction = unsigned_tx . sign (signing_key) . unwrap () ; UncommittedTransaction { transaction , builder : self , post_commit_action : PostCommitAction :: UpdateStorageOnly , } }"
            ],
            "generics": []
          },
          "type_references": [
            "TestTransactionBuilder"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/api/types.rs",
      "path": "../crates/common/src/api/types.rs",
      "relative_path": "crates/common/src/api/types.rs",
      "file_size": 1932,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/types.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/types.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/types.rs#use_crate_{account_Account,digest_Digest}",
            "path": "crate :: { account :: Account , digest :: Digest }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#AccountRequest",
            "name": "AccountRequest",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#AccountResponse",
            "name": "AccountResponse",
            "visibility": "pub",
            "fields": [
              {
                "name": "account",
                "type_name": "Option < Account >",
                "visibility": "pub"
              },
              {
                "name": "proof",
                "type_name": "HashedMerkleProof",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#CommitmentResponse",
            "name": "CommitmentResponse",
            "visibility": "pub",
            "fields": [
              {
                "name": "commitment",
                "type_name": "Digest",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#HashedMerkleProof",
            "name": "HashedMerkleProof",
            "visibility": "pub",
            "fields": [
              {
                "name": "leaf",
                "type_name": "Option < Digest >",
                "visibility": "pub"
              },
              {
                "name": "siblings",
                "type_name": "Vec < Digest >",
                "visibility": "pub"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/types.rs#impl_HashedMerkleProof",
            "target_type": "HashedMerkleProof",
            "trait_name": null,
            "items": [
              "pub fn empty () -> Self { Self { leaf : None , siblings : vec ! [] , } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/types.rs#impl_Default_HashedMerkleProof",
            "target_type": "HashedMerkleProof",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { Self :: empty () }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/types.rs#use_serde_{Deserialize,Serialize}",
            "path": "serde :: { Deserialize , Serialize }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/types.rs#use_utoipa_ToSchema",
            "path": "utoipa :: ToSchema",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/types.rs#use_crate_{account_Account,digest_Digest}",
            "path": "crate :: { account :: Account , digest :: Digest }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#AccountRequest",
            "name": "AccountRequest",
            "visibility": "pub",
            "fields": [
              {
                "name": "id",
                "type_name": "String",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Default",
            "Debug",
            "Serialize",
            "Deserialize",
            "ToSchema"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#AccountResponse",
            "name": "AccountResponse",
            "visibility": "pub",
            "fields": [
              {
                "name": "account",
                "type_name": "Option < Account >",
                "visibility": "pub"
              },
              {
                "name": "proof",
                "type_name": "HashedMerkleProof",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Default",
            "Debug",
            "Serialize",
            "Deserialize",
            "ToSchema"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#CommitmentResponse",
            "name": "CommitmentResponse",
            "visibility": "pub",
            "fields": [
              {
                "name": "commitment",
                "type_name": "Digest",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Default",
            "Debug",
            "Serialize",
            "Deserialize",
            "PartialEq",
            "ToSchema"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/types.rs#HashedMerkleProof",
            "name": "HashedMerkleProof",
            "visibility": "pub",
            "fields": [
              {
                "name": "leaf",
                "type_name": "Option < Digest >",
                "visibility": "pub"
              },
              {
                "name": "siblings",
                "type_name": "Vec < Digest >",
                "visibility": "pub"
              }
            ],
            "generics": []
          },
          "derives": [
            "Debug",
            "Serialize",
            "Deserialize",
            "ToSchema"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/types.rs#impl_HashedMerkleProof",
            "target_type": "HashedMerkleProof",
            "trait_name": null,
            "items": [
              "pub fn empty () -> Self { Self { leaf : None , siblings : vec ! [] , } }"
            ],
            "generics": []
          },
          "type_references": [
            "HashedMerkleProof"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/types.rs#impl_Default_HashedMerkleProof",
            "target_type": "HashedMerkleProof",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { Self :: empty () }"
            ],
            "generics": []
          },
          "type_references": [
            "HashedMerkleProof"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/api/mod.rs",
      "path": "../crates/common/src/api/mod.rs",
      "relative_path": "crates/common/src/api/mod.rs",
      "file_size": 6481,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/api/mod.rs#mock",
            "name": "mock",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/api/mod.rs#noop",
            "name": "noop",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/api/mod.rs#types",
            "name": "types",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_prism_keys_{SigningKey,VerifyingKey}",
            "path": "prism_keys :: { SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_std_{error_Error,fmt_{Debug,Display,Formatter},future_Future,sync_Arc,time_Duration,}",
            "path": "std :: { error :: Error , fmt :: { Debug , Display , Formatter } , future :: Future , sync :: Arc , time :: Duration , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_crate_{account_Account,builder_RequestBuilder,operation_SignatureBundle,transaction_{Transaction,TransactionError},}",
            "path": "crate :: { account :: Account , builder :: RequestBuilder , operation :: SignatureBundle , transaction :: { Transaction , TransactionError } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_types_{AccountResponse,CommitmentResponse}",
            "path": "types :: { AccountResponse , CommitmentResponse }",
            "visibility": "private"
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/api/mod.rs#PrismApiError",
            "name": "PrismApiError",
            "visibility": "pub",
            "variants": [
              "Transaction",
              "RequestFailed",
              "InvalidTarget",
              "SerdeFailed",
              "Any",
              "Unknown"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_Display_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut Formatter < '_ >) -> std :: fmt :: Result { match self { Self :: Transaction (err) => write ! (f , \"Transaction error {}\" , err) , Self :: RequestFailed (msg) => write ! (f , \"Request execution failed: {}\" , msg) , Self :: InvalidTarget (msg) => write ! (f , \"Invalid target: {}\" , msg) , Self :: SerdeFailed (msg) => write ! (f , \"(De)Serialization error: {}\" , msg) , Self :: Any (msg) => write ! (f , \"Unspecific error: {}\" , msg) , Self :: Unknown => write ! (f , \"Unknown error\") , } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_Error_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "Error",
            "items": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_From<TransactionError>_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "From < TransactionError >",
            "items": [
              "fn from (err : TransactionError) -> Self { PrismApiError :: Transaction (err) }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_From<anyhow::Error>_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "From < anyhow :: Error >",
            "items": [
              "fn from (err : anyhow :: Error) -> Self { PrismApiError :: Any (Arc :: new (err)) }"
            ],
            "generics": []
          }
        },
        {
          "Trait": {
            "@type": "rust:Trait",
            "@id": "crates/common/src/api/mod.rs#PrismApi",
            "name": "PrismApi",
            "visibility": "pub",
            "items": [
              "type Timer : PrismApiTimer ;",
              "async fn get_account (& self , id : & str) -> Result < AccountResponse , PrismApiError > ;",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > ;",
              "async fn post_transaction (& self , transaction : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > ;",
              "fn build_request (& self) -> RequestBuilder < Self > { RequestBuilder :: new_with_prism (self) }",
              "async fn register_service (& self , id : String , challenge_key : VerifyingKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . register_service () . with_id (id) . with_key (signing_key . verifying_key ()) . requiring_signed_challenge (challenge_key) ? . sign (signing_key) ? . send () . await }",
              "async fn create_account (& self , id : String , service_id : String , service_signing_key : & SigningKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . create_account () . with_id (id) . for_service_with_id (service_id) . with_key (signing_key . verifying_key ()) . meeting_signed_challenge (service_signing_key) ? . sign (signing_key) ? . send () . await }",
              "async fn add_key (& self , account : & Account , key : VerifyingKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . add_key (key) ? . sign (signing_key) ? . send () . await }",
              "async fn revoke_key (& self , account : & Account , key : VerifyingKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . revoke_key (key) ? . sign (signing_key) ? . send () . await }",
              "async fn add_data (& self , account : & Account , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . add_data (data , data_signature) ? . sign (signing_key) ? . send () . await }",
              "async fn set_data (& self , account : & Account , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . set_data (data , data_signature) ? . sign (signing_key) ? . send () . await }"
            ],
            "generics": []
          }
        },
        {
          "Trait": {
            "@type": "rust:Trait",
            "@id": "crates/common/src/api/mod.rs#PrismApiTimer",
            "name": "PrismApiTimer",
            "visibility": "pub",
            "items": [
              "fn sleep (duration : Duration) -> impl Future < Output = () > + Send ;"
            ],
            "generics": []
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/common/src/api/mod.rs#DEFAULT_POLLING_INTERVAL",
            "name": "DEFAULT_POLLING_INTERVAL",
            "visibility": "private",
            "type_name": "Duration"
          }
        },
        {
          "Trait": {
            "@type": "rust:Trait",
            "@id": "crates/common/src/api/mod.rs#PendingTransaction",
            "name": "PendingTransaction",
            "visibility": "pub",
            "items": [
              "type Timer : PrismApiTimer ;",
              "async fn wait (& self) -> Result < Account , PrismApiError > { self . wait_with_interval (DEFAULT_POLLING_INTERVAL) . await }",
              "async fn wait_with_interval (& self , interval : Duration) -> Result < Account , PrismApiError > ;"
            ],
            "generics": [
              "'a"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/mod.rs#PendingTransactionImpl",
            "name": "PendingTransactionImpl",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "& 'a P",
                "visibility": "private"
              },
              {
                "name": "transaction",
                "type_name": "Transaction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_PendingTransactionImpl<'a,P>",
            "target_type": "PendingTransactionImpl < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : & 'a P , transaction : Transaction) -> Self { Self { prism , transaction } }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_PendingTransaction<'a>_PendingTransactionImpl<'a,P>",
            "target_type": "PendingTransactionImpl < 'a , P >",
            "trait_name": "PendingTransaction < 'a >",
            "items": [
              "type Timer = P :: Timer ;",
              "async fn wait_with_interval (& self , interval : Duration) -> Result < Account , PrismApiError > { loop { if let AccountResponse { account : Some (account) , proof : _ , } = self . prism . get_account (& self . transaction . id) . await ? { if account . nonce () > self . transaction . nonce { return Ok (account) ; } } ; Self :: Timer :: sleep (interval) . await ; } }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        }
      ],
      "enhanced_items": [
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/api/mod.rs#mock",
            "name": "mock",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/api/mod.rs#noop",
            "name": "noop",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Module": {
            "@type": "rust:Module",
            "@id": "crates/common/src/api/mod.rs#types",
            "name": "types",
            "visibility": "pub",
            "items": []
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_prism_keys_{SigningKey,VerifyingKey}",
            "path": "prism_keys :: { SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_std_{error_Error,fmt_{Debug,Display,Formatter},future_Future,sync_Arc,time_Duration,}",
            "path": "std :: { error :: Error , fmt :: { Debug , Display , Formatter } , future :: Future , sync :: Arc , time :: Duration , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_crate_{account_Account,builder_RequestBuilder,operation_SignatureBundle,transaction_{Transaction,TransactionError},}",
            "path": "crate :: { account :: Account , builder :: RequestBuilder , operation :: SignatureBundle , transaction :: { Transaction , TransactionError } , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mod.rs#use_types_{AccountResponse,CommitmentResponse}",
            "path": "types :: { AccountResponse , CommitmentResponse }",
            "visibility": "private"
          }
        },
        {
          "Enum": {
            "@type": "rust:Enum",
            "@id": "crates/common/src/api/mod.rs#PrismApiError",
            "name": "PrismApiError",
            "visibility": "pub",
            "variants": [
              "Transaction",
              "RequestFailed",
              "InvalidTarget",
              "SerdeFailed",
              "Any",
              "Unknown"
            ],
            "generics": []
          },
          "derives": [
            "Clone",
            "Debug"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_Display_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "Display",
            "items": [
              "fn fmt (& self , f : & mut Formatter < '_ >) -> std :: fmt :: Result { match self { Self :: Transaction (err) => write ! (f , \"Transaction error {}\" , err) , Self :: RequestFailed (msg) => write ! (f , \"Request execution failed: {}\" , msg) , Self :: InvalidTarget (msg) => write ! (f , \"Invalid target: {}\" , msg) , Self :: SerdeFailed (msg) => write ! (f , \"(De)Serialization error: {}\" , msg) , Self :: Any (msg) => write ! (f , \"Unspecific error: {}\" , msg) , Self :: Unknown => write ! (f , \"Unknown error\") , } }"
            ],
            "generics": []
          },
          "type_references": [
            "PrismApiError"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_Error_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "Error",
            "items": [],
            "generics": []
          },
          "type_references": [
            "PrismApiError"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_From<TransactionError>_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "From < TransactionError >",
            "items": [
              "fn from (err : TransactionError) -> Self { PrismApiError :: Transaction (err) }"
            ],
            "generics": []
          },
          "type_references": [
            "PrismApiError"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_From<anyhow::Error>_PrismApiError",
            "target_type": "PrismApiError",
            "trait_name": "From < anyhow :: Error >",
            "items": [
              "fn from (err : anyhow :: Error) -> Self { PrismApiError :: Any (Arc :: new (err)) }"
            ],
            "generics": []
          },
          "type_references": [
            "PrismApiError"
          ]
        },
        {
          "Trait": {
            "@type": "rust:Trait",
            "@id": "crates/common/src/api/mod.rs#PrismApi",
            "name": "PrismApi",
            "visibility": "pub",
            "items": [
              "type Timer : PrismApiTimer ;",
              "async fn get_account (& self , id : & str) -> Result < AccountResponse , PrismApiError > ;",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > ;",
              "async fn post_transaction (& self , transaction : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > ;",
              "fn build_request (& self) -> RequestBuilder < Self > { RequestBuilder :: new_with_prism (self) }",
              "async fn register_service (& self , id : String , challenge_key : VerifyingKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . register_service () . with_id (id) . with_key (signing_key . verifying_key ()) . requiring_signed_challenge (challenge_key) ? . sign (signing_key) ? . send () . await }",
              "async fn create_account (& self , id : String , service_id : String , service_signing_key : & SigningKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . create_account () . with_id (id) . for_service_with_id (service_id) . with_key (signing_key . verifying_key ()) . meeting_signed_challenge (service_signing_key) ? . sign (signing_key) ? . send () . await }",
              "async fn add_key (& self , account : & Account , key : VerifyingKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . add_key (key) ? . sign (signing_key) ? . send () . await }",
              "async fn revoke_key (& self , account : & Account , key : VerifyingKey , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . revoke_key (key) ? . sign (signing_key) ? . send () . await }",
              "async fn add_data (& self , account : & Account , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . add_data (data , data_signature) ? . sign (signing_key) ? . send () . await }",
              "async fn set_data (& self , account : & Account , data : Vec < u8 > , data_signature : SignatureBundle , signing_key : & SigningKey ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { self . build_request () . to_modify_account (account) . set_data (data , data_signature) ? . sign (signing_key) ? . send () . await }"
            ],
            "generics": []
          }
        },
        {
          "Trait": {
            "@type": "rust:Trait",
            "@id": "crates/common/src/api/mod.rs#PrismApiTimer",
            "name": "PrismApiTimer",
            "visibility": "pub",
            "items": [
              "fn sleep (duration : Duration) -> impl Future < Output = () > + Send ;"
            ],
            "generics": []
          }
        },
        {
          "Const": {
            "@type": "rust:Const",
            "@id": "crates/common/src/api/mod.rs#DEFAULT_POLLING_INTERVAL",
            "name": "DEFAULT_POLLING_INTERVAL",
            "visibility": "private",
            "type_name": "Duration"
          }
        },
        {
          "Trait": {
            "@type": "rust:Trait",
            "@id": "crates/common/src/api/mod.rs#PendingTransaction",
            "name": "PendingTransaction",
            "visibility": "pub",
            "items": [
              "type Timer : PrismApiTimer ;",
              "async fn wait (& self) -> Result < Account , PrismApiError > { self . wait_with_interval (DEFAULT_POLLING_INTERVAL) . await }",
              "async fn wait_with_interval (& self , interval : Duration) -> Result < Account , PrismApiError > ;"
            ],
            "generics": [
              "'a"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/mod.rs#PendingTransactionImpl",
            "name": "PendingTransactionImpl",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "& 'a P",
                "visibility": "private"
              },
              {
                "name": "transaction",
                "type_name": "Transaction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_PendingTransactionImpl<'a,P>",
            "target_type": "PendingTransactionImpl < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : & 'a P , transaction : Transaction) -> Self { Self { prism , transaction } }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "PendingTransactionImpl",
            "P"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mod.rs#impl_PendingTransaction<'a>_PendingTransactionImpl<'a,P>",
            "target_type": "PendingTransactionImpl < 'a , P >",
            "trait_name": "PendingTransaction < 'a >",
            "items": [
              "type Timer = P :: Timer ;",
              "async fn wait_with_interval (& self , interval : Duration) -> Result < Account , PrismApiError > { loop { if let AccountResponse { account : Some (account) , proof : _ , } = self . prism . get_account (& self . transaction . id) . await ? { if account . nonce () > self . transaction . nonce { return Ok (account) ; } } ; Self :: Timer :: sleep (interval) . await ; } }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "P",
            "PendingTransactionImpl"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/api/mock.rs",
      "path": "../crates/common/src/api/mock.rs",
      "relative_path": "crates/common/src/api/mock.rs",
      "file_size": 1778,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_mockall_mock",
            "path": "mockall :: mock",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_std_time_Duration",
            "path": "std :: time :: Duration",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_crate_{account_Account,api_PendingTransaction,transaction_Transaction}",
            "path": "crate :: { account :: Account , api :: PendingTransaction , transaction :: Transaction }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_super_{types_{AccountResponse,CommitmentResponse},PrismApi,PrismApiError,PrismApiTimer,}",
            "path": "super :: { types :: { AccountResponse , CommitmentResponse } , PrismApi , PrismApiError , PrismApiTimer , }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/mock.rs#MockPrismTimer",
            "name": "MockPrismTimer",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_PrismApiTimer_MockPrismTimer",
            "target_type": "MockPrismTimer",
            "trait_name": "PrismApiTimer",
            "items": [
              "async fn sleep (_ : Duration) { }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/mock.rs#MockPrismPendingTransaction",
            "name": "MockPrismPendingTransaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "result",
                "type_name": "Result < Account , PrismApiError >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_MockPrismPendingTransaction",
            "target_type": "MockPrismPendingTransaction",
            "trait_name": null,
            "items": [
              "pub fn with_result (result : Result < Account , PrismApiError >) -> Self { Self { result } }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_PendingTransaction<'_>_MockPrismPendingTransaction",
            "target_type": "MockPrismPendingTransaction",
            "trait_name": "PendingTransaction < '_ >",
            "items": [
              "type Timer = MockPrismTimer ;",
              "async fn wait_with_interval (& self , _ : Duration) -> Result < Account , PrismApiError > { self . result . clone () }"
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_PrismApi_MockPrismApi",
            "target_type": "MockPrismApi",
            "trait_name": "PrismApi",
            "items": [
              "type Timer = MockPrismTimer ;",
              "async fn get_account (& self , id : & str) -> Result < AccountResponse , PrismApiError > { MockPrismApi :: get_account (self , id) . await }",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > { MockPrismApi :: get_commitment (self) . await }",
              "async fn post_transaction (& self , transaction : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { MockPrismApi :: post_transaction (self , transaction) . await }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_mockall_mock",
            "path": "mockall :: mock",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_std_time_Duration",
            "path": "std :: time :: Duration",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_crate_{account_Account,api_PendingTransaction,transaction_Transaction}",
            "path": "crate :: { account :: Account , api :: PendingTransaction , transaction :: Transaction }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/mock.rs#use_super_{types_{AccountResponse,CommitmentResponse},PrismApi,PrismApiError,PrismApiTimer,}",
            "path": "super :: { types :: { AccountResponse , CommitmentResponse } , PrismApi , PrismApiError , PrismApiTimer , }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/mock.rs#MockPrismTimer",
            "name": "MockPrismTimer",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_PrismApiTimer_MockPrismTimer",
            "target_type": "MockPrismTimer",
            "trait_name": "PrismApiTimer",
            "items": [
              "async fn sleep (_ : Duration) { }"
            ],
            "generics": []
          },
          "type_references": [
            "MockPrismTimer"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/mock.rs#MockPrismPendingTransaction",
            "name": "MockPrismPendingTransaction",
            "visibility": "pub",
            "fields": [
              {
                "name": "result",
                "type_name": "Result < Account , PrismApiError >",
                "visibility": "private"
              }
            ],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_MockPrismPendingTransaction",
            "target_type": "MockPrismPendingTransaction",
            "trait_name": null,
            "items": [
              "pub fn with_result (result : Result < Account , PrismApiError >) -> Self { Self { result } }"
            ],
            "generics": []
          },
          "type_references": [
            "MockPrismPendingTransaction"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_PendingTransaction<'_>_MockPrismPendingTransaction",
            "target_type": "MockPrismPendingTransaction",
            "trait_name": "PendingTransaction < '_ >",
            "items": [
              "type Timer = MockPrismTimer ;",
              "async fn wait_with_interval (& self , _ : Duration) -> Result < Account , PrismApiError > { self . result . clone () }"
            ],
            "generics": []
          },
          "type_references": [
            "MockPrismPendingTransaction"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/mock.rs#impl_PrismApi_MockPrismApi",
            "target_type": "MockPrismApi",
            "trait_name": "PrismApi",
            "items": [
              "type Timer = MockPrismTimer ;",
              "async fn get_account (& self , id : & str) -> Result < AccountResponse , PrismApiError > { MockPrismApi :: get_account (self , id) . await }",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > { MockPrismApi :: get_commitment (self) . await }",
              "async fn post_transaction (& self , transaction : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { MockPrismApi :: post_transaction (self , transaction) . await }"
            ],
            "generics": []
          },
          "type_references": [
            "MockPrismApi"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/api/noop.rs",
      "path": "../crates/common/src/api/noop.rs",
      "relative_path": "crates/common/src/api/noop.rs",
      "file_size": 1208,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_std_time_Duration",
            "path": "std :: time :: Duration",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_super_{types_{AccountResponse,CommitmentResponse},PendingTransaction,PrismApi,PrismApiError,PrismApiTimer,}",
            "path": "super :: { types :: { AccountResponse , CommitmentResponse } , PendingTransaction , PrismApi , PrismApiError , PrismApiTimer , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_crate_{account_Account,transaction_Transaction}",
            "path": "crate :: { account :: Account , transaction :: Transaction }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/noop.rs#NoopTimer",
            "name": "NoopTimer",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/noop.rs#impl_PrismApiTimer_NoopTimer",
            "target_type": "NoopTimer",
            "trait_name": "PrismApiTimer",
            "items": [
              "async fn sleep (_ : Duration) { }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/noop.rs#NoopPendingTransaction",
            "name": "NoopPendingTransaction",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/noop.rs#impl_PendingTransaction<'_>_NoopPendingTransaction",
            "target_type": "NoopPendingTransaction",
            "trait_name": "PendingTransaction < '_ >",
            "items": [
              "type Timer = NoopTimer ;",
              "async fn wait_with_interval (& self , _ : Duration) -> Result < Account , PrismApiError > { Err (PrismApiError :: Unknown) }"
            ],
            "generics": []
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/noop.rs#NoopPrismApi",
            "name": "NoopPrismApi",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/noop.rs#impl_PrismApi_NoopPrismApi",
            "target_type": "NoopPrismApi",
            "trait_name": "PrismApi",
            "items": [
              "type Timer = NoopTimer ;",
              "async fn get_account (& self , _ : & str) -> Result < AccountResponse , PrismApiError > { Err (PrismApiError :: Unknown) }",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > { Err (PrismApiError :: Unknown) }",
              "async fn post_transaction (& self , _ : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { Result :: < NoopPendingTransaction , PrismApiError > :: Err (PrismApiError :: Unknown) }"
            ],
            "generics": []
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_async_trait_async_trait",
            "path": "async_trait :: async_trait",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_std_time_Duration",
            "path": "std :: time :: Duration",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_super_{types_{AccountResponse,CommitmentResponse},PendingTransaction,PrismApi,PrismApiError,PrismApiTimer,}",
            "path": "super :: { types :: { AccountResponse , CommitmentResponse } , PendingTransaction , PrismApi , PrismApiError , PrismApiTimer , }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/api/noop.rs#use_crate_{account_Account,transaction_Transaction}",
            "path": "crate :: { account :: Account , transaction :: Transaction }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/noop.rs#NoopTimer",
            "name": "NoopTimer",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/noop.rs#impl_PrismApiTimer_NoopTimer",
            "target_type": "NoopTimer",
            "trait_name": "PrismApiTimer",
            "items": [
              "async fn sleep (_ : Duration) { }"
            ],
            "generics": []
          },
          "type_references": [
            "NoopTimer"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/noop.rs#NoopPendingTransaction",
            "name": "NoopPendingTransaction",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/noop.rs#impl_PendingTransaction<'_>_NoopPendingTransaction",
            "target_type": "NoopPendingTransaction",
            "trait_name": "PendingTransaction < '_ >",
            "items": [
              "type Timer = NoopTimer ;",
              "async fn wait_with_interval (& self , _ : Duration) -> Result < Account , PrismApiError > { Err (PrismApiError :: Unknown) }"
            ],
            "generics": []
          },
          "type_references": [
            "NoopPendingTransaction"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/api/noop.rs#NoopPrismApi",
            "name": "NoopPrismApi",
            "visibility": "pub",
            "fields": [],
            "generics": []
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/api/noop.rs#impl_PrismApi_NoopPrismApi",
            "target_type": "NoopPrismApi",
            "trait_name": "PrismApi",
            "items": [
              "type Timer = NoopTimer ;",
              "async fn get_account (& self , _ : & str) -> Result < AccountResponse , PrismApiError > { Err (PrismApiError :: Unknown) }",
              "async fn get_commitment (& self) -> Result < CommitmentResponse , PrismApiError > { Err (PrismApiError :: Unknown) }",
              "async fn post_transaction (& self , _ : Transaction ,) -> Result < impl PendingTransaction < Timer = Self :: Timer > , PrismApiError > { Result :: < NoopPendingTransaction , PrismApiError > :: Err (PrismApiError :: Unknown) }"
            ],
            "generics": []
          },
          "type_references": [
            "NoopPrismApi"
          ]
        }
      ]
    },
    {
      "@type": "rust:SourceFile",
      "@id": "crates/common/src/builder.rs",
      "path": "../crates/common/src/builder.rs",
      "relative_path": "crates/common/src/builder.rs",
      "file_size": 9981,
      "last_modified": "2025-06-14 08:09:03 UTC",
      "items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/builder.rs#use_prism_keys_{SigningKey,VerifyingKey}",
            "path": "prism_keys :: { SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/builder.rs#use_crate_{account_Account,api_{noop_NoopPrismApi,PendingTransaction,PrismApi,PrismApiError},digest_Digest,operation_{Operation,ServiceChallenge,ServiceChallengeInput,SignatureBundle},transaction_{Transaction,TransactionError,UnsignedTransaction},}",
            "path": "crate :: { account :: Account , api :: { noop :: NoopPrismApi , PendingTransaction , PrismApi , PrismApiError } , digest :: Digest , operation :: { Operation , ServiceChallenge , ServiceChallengeInput , SignatureBundle } , transaction :: { Transaction , TransactionError , UnsignedTransaction } , }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#RequestBuilder",
            "name": "RequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_RequestBuilder<'a,P>",
            "target_type": "RequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new () -> Self { Self { prism : None } }",
              "pub fn new_with_prism (prism : & 'a P) -> Self { Self { prism : Some (prism) } }",
              "pub fn create_account (self) -> CreateAccountRequestBuilder < 'a , P > { CreateAccountRequestBuilder :: new (self . prism) }",
              "pub fn register_service (self) -> RegisterServiceRequestBuilder < 'a , P > { RegisterServiceRequestBuilder :: new (self . prism) }",
              "pub fn to_modify_account (self , account : & Account) -> ModifyAccountRequestBuilder < 'a , P > { ModifyAccountRequestBuilder :: new (self . prism , account) }",
              "pub fn continue_transaction (self , unsigned_transaction : UnsignedTransaction ,) -> SigningTransactionRequestBuilder < 'a , P > { SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_Default_RequestBuilder<'_,P>",
            "target_type": "RequestBuilder < '_ , P >",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { Self :: new () }"
            ],
            "generics": [
              "P"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#CreateAccountRequestBuilder",
            "name": "CreateAccountRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "service_id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "key",
                "type_name": "Option < VerifyingKey >",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_CreateAccountRequestBuilder<'a,P>",
            "target_type": "CreateAccountRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P >) -> Self { Self { prism , id : String :: new () , service_id : String :: new () , key : None , } }",
              "pub fn with_id (mut self , id : String) -> Self { self . id = id ; self }",
              "pub fn with_key (mut self , key : VerifyingKey) -> Self { self . key = Some (key) ; self }",
              "pub fn for_service_with_id (mut self , service_id : String) -> Self { self . service_id = service_id ; self }",
              "pub fn meeting_signed_challenge (self , service_signing_key : & SigningKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { let Some (key) = self . key else { return Err (TransactionError :: MissingKey) ; } ; let hash = Digest :: hash_items (& [self . id . as_bytes () , self . service_id . as_bytes () , & key . to_bytes () ,]) ; let signature = service_signing_key . sign (hash) . map_err (| _ | TransactionError :: SigningFailed) ? ; let operation = Operation :: CreateAccount { id : self . id . clone () , service_id : self . service_id , challenge : ServiceChallengeInput :: Signed (signature . clone ()) , key , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : 0 , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#RegisterServiceRequestBuilder",
            "name": "RegisterServiceRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "key",
                "type_name": "Option < VerifyingKey >",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_RegisterServiceRequestBuilder<'a,P>",
            "target_type": "RegisterServiceRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P >) -> Self { Self { prism , id : String :: new () , key : None , } }",
              "pub fn with_id (mut self , id : String) -> Self { self . id = id ; self }",
              "pub fn with_key (mut self , key : VerifyingKey) -> Self { self . key = Some (key) ; self }",
              "pub fn requiring_signed_challenge (self , challenge_key : VerifyingKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { let Some (key) = self . key else { return Err (TransactionError :: MissingKey) ; } ; let operation = Operation :: RegisterService { id : self . id . clone () , creation_gate : ServiceChallenge :: Signed (challenge_key) , key , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : 0 , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#ModifyAccountRequestBuilder",
            "name": "ModifyAccountRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_ModifyAccountRequestBuilder<'a,P>",
            "target_type": "ModifyAccountRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P > , account : & Account) -> Self { Self { prism , id : account . id () . to_string () , nonce : account . nonce () , } }",
              "pub fn add_key (self , key : VerifyingKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: AddKey { key } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "pub fn revoke_key (self , key : VerifyingKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: RevokeKey { key } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "pub fn add_data (self , data : Vec < u8 > , data_signature : SignatureBundle ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: AddData { data , data_signature , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "pub fn set_data (self , data : Vec < u8 > , data_signature : SignatureBundle ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: SetData { data , data_signature , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "fn validate_id_and_nonce (& self) -> Result < () , TransactionError > { if self . id . len () < 3 { return Err (TransactionError :: InvalidOp (format ! (\"Invalid ID: {}\" , self . id))) ; } if self . nonce == 0 { return Err (TransactionError :: InvalidNonce (self . nonce)) ; } Ok (()) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#SigningTransactionRequestBuilder",
            "name": "SigningTransactionRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "unsigned_transaction",
                "type_name": "UnsignedTransaction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_SigningTransactionRequestBuilder<'a,P>",
            "target_type": "SigningTransactionRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P > , unsigned_transaction : UnsignedTransaction) -> Self { Self { prism , unsigned_transaction , } }",
              "pub fn sign (self , signing_key : & SigningKey ,) -> Result < SendingTransactionRequestBuilder < 'a , P > , TransactionError > { let transaction = self . unsigned_transaction . sign (signing_key) ? ; Ok (SendingTransactionRequestBuilder :: new (self . prism , transaction ,)) }",
              "pub fn with_external_signature (self , signature_bundle : SignatureBundle ,) -> SendingTransactionRequestBuilder < 'a , P > { SendingTransactionRequestBuilder :: new (self . prism , self . unsigned_transaction . externally_signed (signature_bundle) ,) }",
              "pub fn transaction (self) -> UnsignedTransaction { self . unsigned_transaction }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#SendingTransactionRequestBuilder",
            "name": "SendingTransactionRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "transaction",
                "type_name": "Transaction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_SendingTransactionRequestBuilder<'a,P>",
            "target_type": "SendingTransactionRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P > , transaction : Transaction) -> Self { Self { prism , transaction } }",
              "pub async fn send (self ,) -> Result < impl PendingTransaction < 'a , Timer = P :: Timer > , PrismApiError > { let Some (prism) = self . prism else { return Err (TransactionError :: MissingSender . into ()) ; } ; prism . post_transaction (self . transaction) . await }",
              "pub fn transaction (self) -> Transaction { self . transaction }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        }
      ],
      "enhanced_items": [
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/builder.rs#use_prism_keys_{SigningKey,VerifyingKey}",
            "path": "prism_keys :: { SigningKey , VerifyingKey }",
            "visibility": "private"
          }
        },
        {
          "Use": {
            "@type": "rust:Use",
            "@id": "crates/common/src/builder.rs#use_crate_{account_Account,api_{noop_NoopPrismApi,PendingTransaction,PrismApi,PrismApiError},digest_Digest,operation_{Operation,ServiceChallenge,ServiceChallengeInput,SignatureBundle},transaction_{Transaction,TransactionError,UnsignedTransaction},}",
            "path": "crate :: { account :: Account , api :: { noop :: NoopPrismApi , PendingTransaction , PrismApi , PrismApiError } , digest :: Digest , operation :: { Operation , ServiceChallenge , ServiceChallengeInput , SignatureBundle } , transaction :: { Transaction , TransactionError , UnsignedTransaction } , }",
            "visibility": "private"
          }
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#RequestBuilder",
            "name": "RequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_RequestBuilder<'a,P>",
            "target_type": "RequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new () -> Self { Self { prism : None } }",
              "pub fn new_with_prism (prism : & 'a P) -> Self { Self { prism : Some (prism) } }",
              "pub fn create_account (self) -> CreateAccountRequestBuilder < 'a , P > { CreateAccountRequestBuilder :: new (self . prism) }",
              "pub fn register_service (self) -> RegisterServiceRequestBuilder < 'a , P > { RegisterServiceRequestBuilder :: new (self . prism) }",
              "pub fn to_modify_account (self , account : & Account) -> ModifyAccountRequestBuilder < 'a , P > { ModifyAccountRequestBuilder :: new (self . prism , account) }",
              "pub fn continue_transaction (self , unsigned_transaction : UnsignedTransaction ,) -> SigningTransactionRequestBuilder < 'a , P > { SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "P",
            "RequestBuilder"
          ]
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_Default_RequestBuilder<'_,P>",
            "target_type": "RequestBuilder < '_ , P >",
            "trait_name": "Default",
            "items": [
              "fn default () -> Self { Self :: new () }"
            ],
            "generics": [
              "P"
            ]
          },
          "type_references": [
            "P",
            "RequestBuilder"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#CreateAccountRequestBuilder",
            "name": "CreateAccountRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "service_id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "key",
                "type_name": "Option < VerifyingKey >",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_CreateAccountRequestBuilder<'a,P>",
            "target_type": "CreateAccountRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P >) -> Self { Self { prism , id : String :: new () , service_id : String :: new () , key : None , } }",
              "pub fn with_id (mut self , id : String) -> Self { self . id = id ; self }",
              "pub fn with_key (mut self , key : VerifyingKey) -> Self { self . key = Some (key) ; self }",
              "pub fn for_service_with_id (mut self , service_id : String) -> Self { self . service_id = service_id ; self }",
              "pub fn meeting_signed_challenge (self , service_signing_key : & SigningKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { let Some (key) = self . key else { return Err (TransactionError :: MissingKey) ; } ; let hash = Digest :: hash_items (& [self . id . as_bytes () , self . service_id . as_bytes () , & key . to_bytes () ,]) ; let signature = service_signing_key . sign (hash) . map_err (| _ | TransactionError :: SigningFailed) ? ; let operation = Operation :: CreateAccount { id : self . id . clone () , service_id : self . service_id , challenge : ServiceChallengeInput :: Signed (signature . clone ()) , key , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : 0 , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "CreateAccountRequestBuilder",
            "P"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#RegisterServiceRequestBuilder",
            "name": "RegisterServiceRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "key",
                "type_name": "Option < VerifyingKey >",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_RegisterServiceRequestBuilder<'a,P>",
            "target_type": "RegisterServiceRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P >) -> Self { Self { prism , id : String :: new () , key : None , } }",
              "pub fn with_id (mut self , id : String) -> Self { self . id = id ; self }",
              "pub fn with_key (mut self , key : VerifyingKey) -> Self { self . key = Some (key) ; self }",
              "pub fn requiring_signed_challenge (self , challenge_key : VerifyingKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { let Some (key) = self . key else { return Err (TransactionError :: MissingKey) ; } ; let operation = Operation :: RegisterService { id : self . id . clone () , creation_gate : ServiceChallenge :: Signed (challenge_key) , key , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : 0 , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "RegisterServiceRequestBuilder",
            "P"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#ModifyAccountRequestBuilder",
            "name": "ModifyAccountRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "id",
                "type_name": "String",
                "visibility": "private"
              },
              {
                "name": "nonce",
                "type_name": "u64",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_ModifyAccountRequestBuilder<'a,P>",
            "target_type": "ModifyAccountRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P > , account : & Account) -> Self { Self { prism , id : account . id () . to_string () , nonce : account . nonce () , } }",
              "pub fn add_key (self , key : VerifyingKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: AddKey { key } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "pub fn revoke_key (self , key : VerifyingKey ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: RevokeKey { key } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "pub fn add_data (self , data : Vec < u8 > , data_signature : SignatureBundle ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: AddData { data , data_signature , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "pub fn set_data (self , data : Vec < u8 > , data_signature : SignatureBundle ,) -> Result < SigningTransactionRequestBuilder < 'a , P > , TransactionError > { self . validate_id_and_nonce () ? ; let operation = Operation :: SetData { data , data_signature , } ; operation . validate_basic () . map_err (| e | TransactionError :: InvalidOp (e . to_string ())) ? ; let unsigned_transaction = UnsignedTransaction { id : self . id , operation , nonce : self . nonce , } ; Ok (SigningTransactionRequestBuilder :: new (self . prism , unsigned_transaction ,)) }",
              "fn validate_id_and_nonce (& self) -> Result < () , TransactionError > { if self . id . len () < 3 { return Err (TransactionError :: InvalidOp (format ! (\"Invalid ID: {}\" , self . id))) ; } if self . nonce == 0 { return Err (TransactionError :: InvalidNonce (self . nonce)) ; } Ok (()) }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "P",
            "ModifyAccountRequestBuilder"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#SigningTransactionRequestBuilder",
            "name": "SigningTransactionRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "unsigned_transaction",
                "type_name": "UnsignedTransaction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_SigningTransactionRequestBuilder<'a,P>",
            "target_type": "SigningTransactionRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P > , unsigned_transaction : UnsignedTransaction) -> Self { Self { prism , unsigned_transaction , } }",
              "pub fn sign (self , signing_key : & SigningKey ,) -> Result < SendingTransactionRequestBuilder < 'a , P > , TransactionError > { let transaction = self . unsigned_transaction . sign (signing_key) ? ; Ok (SendingTransactionRequestBuilder :: new (self . prism , transaction ,)) }",
              "pub fn with_external_signature (self , signature_bundle : SignatureBundle ,) -> SendingTransactionRequestBuilder < 'a , P > { SendingTransactionRequestBuilder :: new (self . prism , self . unsigned_transaction . externally_signed (signature_bundle) ,) }",
              "pub fn transaction (self) -> UnsignedTransaction { self . unsigned_transaction }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "P",
            "SigningTransactionRequestBuilder"
          ]
        },
        {
          "Struct": {
            "@type": "rust:Struct",
            "@id": "crates/common/src/builder.rs#SendingTransactionRequestBuilder",
            "name": "SendingTransactionRequestBuilder",
            "visibility": "pub",
            "fields": [
              {
                "name": "prism",
                "type_name": "Option < & 'a P >",
                "visibility": "private"
              },
              {
                "name": "transaction",
                "type_name": "Transaction",
                "visibility": "private"
              }
            ],
            "generics": [
              "'a",
              "P"
            ]
          }
        },
        {
          "Impl": {
            "@type": "rust:Impl",
            "@id": "crates/common/src/builder.rs#impl_SendingTransactionRequestBuilder<'a,P>",
            "target_type": "SendingTransactionRequestBuilder < 'a , P >",
            "trait_name": null,
            "items": [
              "pub fn new (prism : Option < & 'a P > , transaction : Transaction) -> Self { Self { prism , transaction } }",
              "pub async fn send (self ,) -> Result < impl PendingTransaction < 'a , Timer = P :: Timer > , PrismApiError > { let Some (prism) = self . prism else { return Err (TransactionError :: MissingSender . into ()) ; } ; prism . post_transaction (self . transaction) . await }",
              "pub fn transaction (self) -> Transaction { self . transaction }"
            ],
            "generics": [
              "'a",
              "P"
            ]
          },
          "type_references": [
            "P",
            "SendingTransactionRequestBuilder"
          ]
        }
      ]
    }
  ],
  "cross_references": [
    {
      "from_id": "crates/common/src/operation.rs",
      "to_id": "anyhow :: { bail , ensure , Result }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/operation.rs",
      "to_id": "serde :: { Deserialize , Serialize }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/operation.rs",
      "to_id": "std :: { self , fmt :: Display }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/operation.rs",
      "to_id": "utoipa :: ToSchema",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/operation.rs",
      "to_id": "prism_keys :: { Signature , SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/operation.rs",
      "to_id": "prism_serde :: raw_or_b64",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/operation.rs#Operation",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#Operation",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#Operation",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#Operation",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#Operation",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#Operation",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#SignatureBundle",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#SignatureBundle",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#SignatureBundle",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#SignatureBundle",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#SignatureBundle",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#SignatureBundle",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallengeInput",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallengeInput",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallengeInput",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallengeInput",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallengeInput",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallengeInput",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallenge",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallenge",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallenge",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallenge",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallenge",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#ServiceChallenge",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/operation.rs#impl_From<SigningKey>_ServiceChallenge",
      "to_id": "trait:From",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/operation.rs#impl_Display_Operation",
      "to_id": "trait:Display",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "std :: { error :: Error , fmt :: { Display , Formatter } , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "anyhow :: Result",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "celestia_types :: Blob",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "prism_keys :: { Signature , SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "prism_serde :: binary :: { FromBinary , ToBinary }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "serde :: { Deserialize , Serialize }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "utoipa :: ToSchema",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs",
      "to_id": "crate :: operation :: { Operation , SignatureBundle }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/transaction.rs#UnsignedTransaction",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#UnsignedTransaction",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#UnsignedTransaction",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#UnsignedTransaction",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#UnsignedTransaction",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#Transaction",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#Transaction",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#Transaction",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#Transaction",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#Transaction",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#Transaction",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#impl_TryFrom<&Blob>_Transaction",
      "to_id": "trait:TryFrom",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/transaction.rs#TransactionError",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#TransactionError",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/transaction.rs#impl_Display_TransactionError",
      "to_id": "trait:Display",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/transaction.rs#impl_Error_TransactionError",
      "to_id": "trait:Error",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs",
      "to_id": "prism_keys :: SigningKey",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs",
      "to_id": "crate :: { account :: Account , operation :: Operation }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "SigningKey::new_ed25519",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "SigningKey::new_ed25519",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "requiring_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "register_service",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "requiring_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "register_service",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "requiring_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "register_service",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "SigningKey::new_ed25519",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "requiring_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "register_service",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_register_service_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "SigningKey::new_ed25519",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "SigningKey::new_ed25519",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "meeting_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "for_service_with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "create_account",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "meeting_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "for_service_with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "create_account",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "meeting_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "for_service_with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "create_account",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "SigningKey::new_ed25519",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "transaction",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "sign",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "unwrap",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "meeting_signed_challenge",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "for_service_with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "with_id",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "create_account",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "Account::builder",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "to_string",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/tests/mod.rs#test_process_create_account_transactions",
      "to_id": "verifying_key",
      "ref_type": "FunctionCall"
    },
    {
      "from_id": "crates/common/src/digest.rs",
      "to_id": "std :: fmt :: Display",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/digest.rs",
      "to_id": "anyhow :: Result",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/digest.rs",
      "to_id": "serde :: { Deserialize , Serialize }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/digest.rs",
      "to_id": "prism_serde :: { base64 :: FromBase64 , hex :: { FromHex , ToHex } , raw_or_hex , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/digest.rs",
      "to_id": "sha2 :: { Digest as _ , Sha256 }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/digest.rs",
      "to_id": "utoipa :: ToSchema",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:Eq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:Copy",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#Digest",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/digest.rs#impl_Default_Digest",
      "to_id": "trait:Default",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/digest.rs#impl_From<[u8;N]>_Digest",
      "to_id": "trait:From",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/digest.rs#impl_AsRef<[u8]>_Digest",
      "to_id": "trait:AsRef",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/digest.rs#impl_FromHex_Digest",
      "to_id": "trait:FromHex",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/digest.rs#impl_FromBase64_Digest",
      "to_id": "trait:FromBase64",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/digest.rs#impl_Display_Digest",
      "to_id": "trait:Display",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/account.rs",
      "to_id": "anyhow :: { anyhow , bail , Result }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/account.rs",
      "to_id": "prism_keys :: VerifyingKey",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/account.rs",
      "to_id": "prism_serde :: raw_or_b64",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/account.rs",
      "to_id": "serde :: { Deserialize , Serialize }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/account.rs",
      "to_id": "utoipa :: ToSchema",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/account.rs",
      "to_id": "crate :: { api :: { noop :: NoopPrismApi , PrismApi } , builder :: { ModifyAccountRequestBuilder , RequestBuilder } , operation :: { Operation , ServiceChallenge } , transaction :: Transaction , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/account.rs#SignedData",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#SignedData",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#SignedData",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#SignedData",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#SignedData",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#SignedData",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:Default",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/account.rs#Account",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/test_transaction_builder.rs",
      "to_id": "std :: collections :: HashMap",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/test_transaction_builder.rs",
      "to_id": "crate :: { account :: Account , digest :: Digest , operation :: { Operation , ServiceChallenge , ServiceChallengeInput , SignatureBundle } , transaction :: { Transaction , UnsignedTransaction } , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/test_transaction_builder.rs",
      "to_id": "prism_keys :: { CryptoAlgorithm , SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/test_transaction_builder.rs#impl_Default_TestTransactionBuilder",
      "to_id": "trait:Default",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/types.rs",
      "to_id": "serde :: { Deserialize , Serialize }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/types.rs",
      "to_id": "utoipa :: ToSchema",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/types.rs",
      "to_id": "crate :: { account :: Account , digest :: Digest }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountRequest",
      "to_id": "trait:Default",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountRequest",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountRequest",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountRequest",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountRequest",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountResponse",
      "to_id": "trait:Default",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountResponse",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountResponse",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountResponse",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#AccountResponse",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#CommitmentResponse",
      "to_id": "trait:Default",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#CommitmentResponse",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#CommitmentResponse",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#CommitmentResponse",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#CommitmentResponse",
      "to_id": "trait:PartialEq",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#CommitmentResponse",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#HashedMerkleProof",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#HashedMerkleProof",
      "to_id": "trait:Serialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#HashedMerkleProof",
      "to_id": "trait:Deserialize",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#HashedMerkleProof",
      "to_id": "trait:ToSchema",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/types.rs#impl_Default_HashedMerkleProof",
      "to_id": "trait:Default",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mod.rs",
      "to_id": "async_trait :: async_trait",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mod.rs",
      "to_id": "prism_keys :: { SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mod.rs",
      "to_id": "std :: { error :: Error , fmt :: { Debug , Display , Formatter } , future :: Future , sync :: Arc , time :: Duration , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mod.rs",
      "to_id": "crate :: { account :: Account , builder :: RequestBuilder , operation :: SignatureBundle , transaction :: { Transaction , TransactionError } , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mod.rs",
      "to_id": "types :: { AccountResponse , CommitmentResponse }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#PrismApiError",
      "to_id": "trait:Clone",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#PrismApiError",
      "to_id": "trait:Debug",
      "ref_type": "Derive"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#impl_Display_PrismApiError",
      "to_id": "trait:Display",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#impl_Error_PrismApiError",
      "to_id": "trait:Error",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#impl_From<TransactionError>_PrismApiError",
      "to_id": "trait:From",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#impl_From<anyhow::Error>_PrismApiError",
      "to_id": "trait:From",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mod.rs#impl_PendingTransaction<'a>_PendingTransactionImpl<'a,P>",
      "to_id": "trait:PendingTransaction",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mock.rs",
      "to_id": "async_trait :: async_trait",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mock.rs",
      "to_id": "mockall :: mock",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mock.rs",
      "to_id": "std :: time :: Duration",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mock.rs",
      "to_id": "crate :: { account :: Account , api :: PendingTransaction , transaction :: Transaction }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mock.rs",
      "to_id": "super :: { types :: { AccountResponse , CommitmentResponse } , PrismApi , PrismApiError , PrismApiTimer , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/mock.rs#impl_PrismApiTimer_MockPrismTimer",
      "to_id": "trait:PrismApiTimer",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mock.rs#impl_PendingTransaction<'_>_MockPrismPendingTransaction",
      "to_id": "trait:PendingTransaction",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/mock.rs#impl_PrismApi_MockPrismApi",
      "to_id": "trait:PrismApi",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/noop.rs",
      "to_id": "async_trait :: async_trait",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/noop.rs",
      "to_id": "std :: time :: Duration",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/noop.rs",
      "to_id": "super :: { types :: { AccountResponse , CommitmentResponse } , PendingTransaction , PrismApi , PrismApiError , PrismApiTimer , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/noop.rs",
      "to_id": "crate :: { account :: Account , transaction :: Transaction }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/api/noop.rs#impl_PrismApiTimer_NoopTimer",
      "to_id": "trait:PrismApiTimer",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/noop.rs#impl_PendingTransaction<'_>_NoopPendingTransaction",
      "to_id": "trait:PendingTransaction",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/api/noop.rs#impl_PrismApi_NoopPrismApi",
      "to_id": "trait:PrismApi",
      "ref_type": "TraitImpl"
    },
    {
      "from_id": "crates/common/src/builder.rs",
      "to_id": "prism_keys :: { SigningKey , VerifyingKey }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/builder.rs",
      "to_id": "crate :: { account :: Account , api :: { noop :: NoopPrismApi , PendingTransaction , PrismApi , PrismApiError } , digest :: Digest , operation :: { Operation , ServiceChallenge , ServiceChallengeInput , SignatureBundle } , transaction :: { Transaction , TransactionError , UnsignedTransaction } , }",
      "ref_type": "Import"
    },
    {
      "from_id": "crates/common/src/builder.rs#impl_Default_RequestBuilder<'_,P>",
      "to_id": "trait:Default",
      "ref_type": "TraitImpl"
    }
  ],
  "total_files": 12,
  "successfully_parsed": 12,
  "failed_files": [],
  "stats": {
    "total_functions": 2,
    "total_structs": 24,
    "total_enums": 6,
    "total_traits": 3,
    "total_impls": 42,
    "total_tests": 2,
    "total_function_calls": 108,
    "total_derives": 80,
    "total_macro_uses": 10
  }
}